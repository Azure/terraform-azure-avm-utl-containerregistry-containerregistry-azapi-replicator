# Task #25 - identity Block Structure Skeleton

## Summary
Created structure skeleton for the `identity` block in `azapi_header`. This block supports managed identity configuration with SystemAssigned, UserAssigned, or both. Only the conditional framework is implemented; individual field implementations are delegated to child tasks.

## Shadow Implementation

```hcl
locals {
  azapi_header = {
    type                  = "Microsoft.ContainerRegistry/registries@2025-04-01"
    name                  = var.name
    location              = var.location
    parent_id             = var.resource_group_id
    tags                  = var.tags
    ignore_null_property  = true
    retry                 = null
    identity = var.identity != null ? {  # <-
      # type = ... # Task #26  # <-
      # userAssignedIdentities = ... # Task #27  # <-
    } : null  # <-
  }
}
```

## Create Phase Verification

**Pattern:** Single-phase resource creation.

**Evidence from Create method (line 461):**
```go
identity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
if err != nil {
    return fmt.Errorf("expanding `identity`: %+v", err)
}
```

Then assigned to the primary create parameters (line 512):
```go
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    Identity: identity,  // <- Assigned to root level
    Properties: &registries.RegistryProperties{
        // ... other properties
    },
    Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
}

if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**Classification:** This field is processed in the **Create phase** (before and during primary `CreateThenPoll`).

**Decision:** Implement in `local.azapi_header.identity` (root-level field in azapi_resource).

## Assignment Path Verification

**Predicted Path:** `identity` (root level in azapi_resource)

**Go Code Evidence:**

From Create method (line 512-514):
```go
parameters := registries.Registry{
    // ...
    Identity: identity,
    // ...
}
```

The `registries.Registry` struct has `Identity` at the root level, not nested under Properties.

**Verified Path:** `identity` (root level)

**Path Comparison:** ✅ MATCH - Identity is a root-level field in azapi_resource, alongside type, name, location, parent_id, tags.

## Provider Schema

From `container_registry_resource.go` (line 145):
```go
"identity": commonschema.SystemAssignedUserAssignedIdentityOptional(),
```

The `commonschema.SystemAssignedUserAssignedIdentityOptional()` returns a standard schema for identity with:
- `type`: Required field specifying identity type
- `identity_ids`: Optional set of User Assigned Identity IDs
- `principal_id`: Computed field (read-only)
- `tenant_id`: Computed field (read-only)

**Schema Details:**
- **Type:** Block (MaxItems: 1, Optional: true)
- **Required:** No (Optional)
- **ForceNew:** No

## Azure API Schema

**Query Result:**
```
ObjectWithOptionalAttrs(map[string]Type{"type":String, "userAssignedIdentities":Map(EmptyObject)}, []string{"type", "userAssignedIdentities"})
```

**API Structure:**
- `type`: String (Required) - Identity type
- `userAssignedIdentities`: Map of empty objects (Optional) - User assigned identity IDs as keys

## Hidden Fields

**Check in Expand Function:**

From `go-azure-helpers/resourcemanager/identity/system_and_user_assigned_map.go` (lines 55-90):
```go
func ExpandSystemAndUserAssignedMap(input []interface{}) (*SystemAndUserAssignedMap, error) {
    identityType := TypeNone
    identityIds := make(map[string]UserAssignedIdentityDetails, 0)

    if len(input) > 0 {
        raw := input[0].(map[string]interface{})
        typeRaw := raw["type"].(string)
        if typeRaw == string(TypeSystemAssigned) {
            identityType = TypeSystemAssigned
        }
        if typeRaw == string(TypeSystemAssignedUserAssigned) {
            identityType = TypeSystemAssignedUserAssigned
        }
        if typeRaw == string(TypeUserAssigned) {
            identityType = TypeUserAssigned
        }

        identityIdsRaw := raw["identity_ids"].(*schema.Set).List()
        for _, v := range identityIdsRaw {
            identityIds[v.(string)] = UserAssignedIdentityDetails{
                // intentionally empty since the expand shouldn't send these values
            }
        }
    }

    if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
        return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
    }

    return &SystemAndUserAssignedMap{
        Type:        identityType,
        IdentityIds: identityIds,
    }, nil
}
```

**Hidden Fields Found:** None. The expand function only processes the two user-visible fields (`type` and `identity_ids`). The `PrincipalId` and `TenantId` fields are read-only (Computed) and set by Azure, not by the expand function.

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**
- `identity` → `identity` (root level)
- `type` → `type` (Task #26)
- `identity_ids` → `userAssignedIdentities` (Task #27)

## Special Handling

### 1. Root-Level Placement
Unlike most fields that go in `body`, identity is a root-level field in azapi_resource's `azapi_header`. This matches Azure's ARM resource structure where identity is alongside sku, location, and tags.

### 2. Conditional Structure
The entire identity block is conditionally created based on `var.identity != null`. When null, the identity key in azapi_header should be `null` (not an empty object).

### 3. Block Structure (Type 3 Task)
This is a Type 3 task - creating only the structure skeleton with comment placeholders for child tasks:
- **Task #26:** `identity.type` - Required field, specifies identity type
- **Task #27:** `identity.identity_ids` - Optional field, user-assigned identity IDs

### 4. No ForceNew Behavior
The identity block does NOT have ForceNew. Changes to identity can be applied in-place through Update.

**Evidence from Update method (line 587-594):**
```go
if d.HasChange("identity") {
    identity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `identity`: %+v", err)
    }

    payload.Identity = identity
}
```

The Update method handles identity changes, confirming no ForceNew behavior.

## Child Tasks Ready for Delegation

After completing this skeleton task, the following child tasks are now ready for implementation:

- **Task #26:** `identity.type` - Implement the required `type` field
- **Task #27:** `identity.identity_ids` - Implement the optional `identity_ids` field

Both child tasks can proceed independently as the parent structure skeleton is now in place.

## Critical Review & Edge Case Analysis

### Null Semantics
- `var.identity = null` → `identity = null` in azapi_header (no identity block sent to API)
- `var.identity = {...}` → `identity = { type: ..., userAssignedIdentities: ... }` in azapi_header

### Boundary Conditions
- **Empty identity:** When `var.identity` is null, the entire identity block is omitted
- **SystemAssigned only:** When type is "SystemAssigned", userAssignedIdentities should be null/omitted (Task #27)
- **UserAssigned only:** When type is "UserAssigned", userAssignedIdentities must be provided (Task #27)
- **Both:** When type is "SystemAssigned, UserAssigned", userAssignedIdentities must be provided (Task #27)

### Idempotency
The conditional structure ensures idempotency:
- When identity is not configured (null), no identity block is sent
- When identity is configured, the same block structure is always generated
- Child tasks (#26, #27) will handle the internal idempotency of field values

### Safe References
All references are null-safe:
- ✅ `var.identity != null` check prevents accessing null object
- ✅ Child tasks will implement their own null checks for nested fields
- ✅ No premature field access in skeleton structure

## Checklist

- ✅ Skeleton structure created in `local.azapi_header.identity`
- ✅ Conditional logic based on `var.identity != null`
- ✅ Comment placeholders added for child tasks (#26, #27)
- ✅ No ForceNew handling (identity is updatable)
- ✅ No hidden fields found in expand function
- ✅ Root-level placement verified (not in body)
- ✅ Create phase verified (single-phase, primary create)
- ✅ Assignment path verified (root level, not in properties)
- ✅ Child tasks identified and documented
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ No modifications to `main.tf`
- ✅ Only skeleton structure created (no field implementations)
- ✅ Proof document created
- ✅ Ready to update `track.md` status to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #25 - identity

### Validation Results

✅ **Type 3 Task (Block Structure Skeleton):** Correctly implements only the conditional structure with comment placeholders for child tasks (#26, #27)
✅ **Root-Level Placement:** Identity correctly placed in `local.azapi_header` (not in `body`), matching executor.md requirements for root-level identity fields
✅ **Conditional Logic:** Proper null handling using `var.identity != null ? { ... } : null` pattern
✅ **Comment Placeholders:** Appropriate placeholders for Task #26 (type) and Task #27 (userAssignedIdentities)
✅ **ForceNew Logic:** Correctly identified NO ForceNew behavior - identity changes are handled in Update method
✅ **Phase Detection:** Field correctly classified as Create phase, root-level field
✅ **Assignment Path Verification:** Verified identity is at root level (`parameters.Identity = identity`), not nested under Properties
✅ **Hidden Fields:** No hidden fields found in expand function (PrincipalId/TenantId are Computed/read-only)
✅ **Null Handling:** Correctly propagates null semantics (null → no identity block sent to API)
✅ **Validations:** No premature validations in skeleton task (appropriate for Type 3)
✅ **Deferred Work Completion:** No deferred work exists for this task (no following.md file)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Merge Stability:** No merge issues (identity uses object literal in azapi_header)
✅ **Scope Compliance:** Only implements skeleton structure; no field implementations from child tasks
✅ **Edge Cases:** Proper analysis of null semantics, boundary conditions, and idempotency in proof document

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The Type 3 task correctly creates only the block structure skeleton with appropriate conditional logic and placeholders for child tasks. Root-level identity placement in `azapi_header` matches Azure ARM resource structure. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
