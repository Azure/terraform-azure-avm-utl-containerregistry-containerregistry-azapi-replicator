# Task #8: export_policy_enabled - Migration Proof

## Summary

Successfully migrated `export_policy_enabled` from azurerm_container_registry to azapi_resource. The field is a boolean that controls whether the export policy is enabled, with a default of `true`. It maps to `properties.policies.exportPolicy.status` in the Azure API with values "enabled" or "disabled". All validations from CustomizeDiff have been replicated in variables.tf.

## Shadow Implementation

```hcl
# variables.tf
variable "export_policy_enabled" {  # <-
  type        = bool  # <-
  default     = true  # <-
  nullable    = false  # <-
  description = "(Optional) Boolean value that indicates whether export policy is enabled. Defaults to `true`. In order to set it to `false`, make sure the `public_network_access_enabled` is also set to `false`."  # <-

  validation {  # <-
    condition     = var.export_policy_enabled == true || var.sku == "Premium"  # <-
    error_message = "an ACR export policy can only be disabled when using the Premium Sku. If you are downgrading from a Premium SKU please unset `export_policy_enabled` or set `export_policy_enabled = true`"  # <-
  }  # <-

  validation {  # <-
    condition     = var.export_policy_enabled == true || var.public_network_access_enabled == false  # <-
    error_message = "to disable export of artifacts, `public_network_access_enabled` must also be `false`"  # <-
  }  # <-
}  # <-

# migrate_main.tf
locals {
  body = {
    properties = {
      # ... other fields ...
      policies = {  # <-
        exportPolicy = {  # <-
          status = var.export_policy_enabled ? "enabled" : "disabled"  # <-
        }  # <-
      }  # <-
    }
  }
}
```

## Create Phase Verification

**Query:** Create method in `container_registry_resource.go`

**Pattern:** Single-phase resource creation

**Go Code Evidence:**
```go
// Line 524 in resourceContainerRegistryCreate
parameters := registries.Registry{
    // ... other fields ...
    Properties: &registries.RegistryProperties{
        // ... other properties ...
        Policies: &registries.Policies{
            QuarantinePolicy: expandQuarantinePolicy(d.Get("quarantine_policy_enabled").(bool)),
            RetentionPolicy:  retentionPolicy,
            TrustPolicy:      trustPolicy,
            ExportPolicy:     expandExportPolicy(d.Get("export_policy_enabled").(bool)),
        },
        // ... more properties ...
    },
    // ... more fields ...
}

if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**Decision:** The field is included in the primary Create operation. It belongs in `local.body`, not a post-creation operation.

## Assignment Path Verification

**Predicted Path:** `properties.policies.exportPolicy`

**Go Code Evidence - expandExportPolicy function:**
```go
// Lines 1082-1092
func expandExportPolicy(enabled bool) *registries.ExportPolicy {
	exportPolicy := registries.ExportPolicy{
		Status: pointer.To(registries.ExportPolicyStatusDisabled),
	}

	if enabled {
		exportPolicy.Status = pointer.To(registries.ExportPolicyStatusEnabled)
	}

	return &exportPolicy
}
```

**Go Code Evidence - Assignment in Create:**
```go
// Line 524
Properties: &registries.RegistryProperties{
    Policies: &registries.Policies{
        // ...
        ExportPolicy: expandExportPolicy(d.Get("export_policy_enabled").(bool)),
    },
}
```

**Verified Path:** `properties.policies.exportPolicy.status`

**Path Comparison:** ✅ Match - The field is assigned to `Policies.ExportPolicy`, which nests under `Properties`, resulting in the path `properties.policies.exportPolicy`.

## Provider Schema

**File:** `internal/services/containers/container_registry_resource.go`

**Schema Definition (Lines 250-254):**
```go
"export_policy_enabled": {
    Type:     pluginsdk.TypeBool,
    Optional: true,
    Default:  true,
},
```

**Key Attributes:**
- Type: `TypeBool`
- Optional: `true`
- Default: `true`
- ForceNew: Not specified (false)
- Sensitive: Not specified (false)

## Azure API Schema

**Resource Type:** `Microsoft.ContainerRegistry/registries@2025-04-01`

**Property Path:** `body.properties.policies.exportPolicy`

**Schema:**
```
ObjectWithOptionalAttrs(map[string]Type{"status":String}, []string{"status"})
```

**Documentation:**
```json
{
  "status": "The value that indicates whether the policy is enabled or not. (Possible values: enabled,disabled)"
}
```

**API Structure:**
- `exportPolicy` is an object under `properties.policies`
- Contains a `status` field of type String
- Possible values: "enabled", "disabled"

## Hidden Fields

No hidden fields detected. The `exportPolicy` object only contains the `status` field, which is directly mapped from the boolean variable.

## Mapping

| Terraform (azurerm) | Azure API | Type Transformation |
|---------------------|-----------|---------------------|
| `export_policy_enabled` (bool) | `properties.policies.exportPolicy.status` (string) | `true` → `"enabled"`, `false` → `"disabled"` |

**Naming Convention:**
- Provider: `export_policy_enabled` (snake_case)
- Azure API: `exportPolicy` (camelCase)

## Special Handling

### 1. Default Value
- **Provider Default:** `true`
- **Implementation:** Added `default = true` and `nullable = false` to the variable in `variables.tf`
- **Rationale:** Root-level argument with default requires both `default` value and `nullable = false`

### 2. Type Transformation
- **Provider Type:** Boolean
- **API Type:** String with values "enabled" or "disabled"
- **Implementation:** Ternary expression `var.export_policy_enabled ? "enabled" : "disabled"`

### 3. Cross-Field Validations (from CustomizeDiff)

**Validation 1 - SKU Requirement (Lines 342-345):**
```go
exportPolicyEnabled := d.Get("export_policy_enabled").(bool)
if !exportPolicyEnabled {
    if !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
        return errors.New("an ACR export policy can only be disabled when using the Premium Sku. If you are downgrading from a Premium SKU please unset `export_policy_enabled` or set `export_policy_enabled = true`")
    }
    // ...
}
```

**Implementation:**
```hcl
validation {
  condition     = var.export_policy_enabled == true || var.sku == "Premium"
  error_message = "an ACR export policy can only be disabled when using the Premium Sku. If you are downgrading from a Premium SKU please unset `export_policy_enabled` or set `export_policy_enabled = true`"
}
```

**Validation 2 - Public Network Access Requirement (Lines 346-348):**
```go
if d.Get("public_network_access_enabled").(bool) {
    return errors.New("to disable export of artifacts, `public_network_access_enabled` must also be `false`")
}
```

**Implementation:**
```hcl
validation {
  condition     = var.export_policy_enabled == true || var.public_network_access_enabled == false
  error_message = "to disable export of artifacts, `public_network_access_enabled` must also be `false`"
}
```

**Note:** These validations reference `var.sku` and `var.public_network_access_enabled`, which exist in the current codebase:
- `var.sku` - Completed in Task #4
- `var.public_network_access_enabled` - Not yet implemented (Task #10), but variable exists in `variables.tf` with a default value

### 4. ForceNew Behavior
- **Schema ForceNew:** Not set (false)
- **CustomizeDiff:** No ForceNew logic detected for this field
- **Implementation:** No entry needed in `replace_triggers_external_values`

### 5. Update Phase Support

**Go Code Evidence (Lines 719-726 in resourceContainerRegistryUpdate):**
```go
if d.HasChange("export_policy_enabled") {
    payload.Properties.Policies.ExportPolicy = &registries.ExportPolicy{
        Status: pointer.To(registries.ExportPolicyStatusDisabled),
    }

    if v := d.Get("export_policy_enabled").(bool); v {
        payload.Properties.Policies.ExportPolicy = &registries.ExportPolicy{
            Status: pointer.To(registries.ExportPolicyStatusEnabled),
        }
    }
}
```

**Observation:** The field supports in-place updates. Changes to `export_policy_enabled` are handled by the Update method.

## Deferred Work Completion

Checked `following.md` - File does not exist. No deferred work found for this task.

## Edge Case Analysis

### Null Semantics
- **Provider Default:** `true` (not nullable)
- **Implementation:** `default = true, nullable = false`
- **Edge Case:** Users cannot set this to null; it always has a value

### Boolean to String Transformation
- **Edge Case:** Ensuring correct mapping
- **Implementation:** Using ternary `var.export_policy_enabled ? "enabled" : "disabled"`
- **Coverage:** Handles both `true` → "enabled" and `false` → "disabled"

### Cross-Field Dependencies
- **Edge Case 1:** Setting `export_policy_enabled = false` without Premium SKU
- **Mitigation:** Validation checks `var.sku == "Premium"` when disabled
- **Edge Case 2:** Setting `export_policy_enabled = false` with `public_network_access_enabled = true`
- **Mitigation:** Validation checks `var.public_network_access_enabled == false` when disabled

### Nested Structure Handling
- **Edge Case:** Multiple policies in the `policies` object
- **Implementation:** Using direct object assignment in `body.properties.policies`
- **Future Compatibility:** When other policies are added (quarantine, retention, trust), they will be merged at the same level

## Checklist

- ✅ Property in correct local (`local.body.properties.policies.exportPolicy`)
- ✅ ForceNew not needed (field supports in-place updates)
- ✅ All logic exactly replicated from provider (CustomizeDiff validations implemented)
- ✅ Validations implemented in variables.tf (2 cross-field validations)
- ✅ TODO comment not needed (field is not sensitive/ephemeral)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (no following.md file exists)
- ✅ Critical review completed (null semantics, edge cases, cross-field dependencies)
- ✅ Edge Case Analysis in proof (documented above)
- ✅ Proof created (this document)
- ⏳ track.md update pending
- ✅ Self-Review: Added only export_policy_enabled implementation, no other fields

## Notes

1. **Default Value:** The provider has `Default: true`, which has been replicated with `default = true` and `nullable = false` in variables.tf.

2. **Cross-Variable Validation:** Both validations reference other variables (`var.sku` and `var.public_network_access_enabled`). Since Terraform 1.9+ supports cross-variable validation, these are implemented directly in the variable's validation blocks rather than deferring to migrate_validation.tf.

3. **API Mapping:** The boolean value is transformed to a string status value. The expand function in the provider shows this mapping: `true` → `ExportPolicyStatusEnabled` (which is "enabled"), `false` → `ExportPolicyStatusDisabled` (which is "disabled").

4. **Nested Structure:** The `policies` object is introduced in this task. Other policy fields (quarantinePolicy, retentionPolicy, trustPolicy) will be added by their respective tasks and merged at the same level.

5. **No ForceNew:** Unlike some other fields in this resource, `export_policy_enabled` does not require ForceNew behavior. Changes are handled in-place during updates.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #8 - export_policy_enabled

### Validation Results

✅ **Variable Definition:** Correct type (bool), default (true), and nullable = false for root-level argument with default
✅ **Cross-Variable Validations:** Both validations correctly implemented in variables.tf using Terraform 1.9+ cross-variable validation syntax
✅ **Body Implementation:** Correctly placed in `local.body.properties.policies.exportPolicy.status` with proper boolean-to-string transformation
✅ **ForceNew Logic:** Correctly omitted from `replace_triggers_external_values` (field supports in-place updates)
✅ **Stable Keys:** No merge conflicts, `policies.exportPolicy` appears only once
✅ **Phase Detection:** Field correctly placed in Create phase (`local.body`)
✅ **Type Conversion:** Correct transformation from bool to string ("enabled"/"disabled")
✅ **Null Handling:** Correctly uses default = true with nullable = false
✅ **Validations:** All provider validations (SKU requirement, public_network_access_enabled requirement) implemented exactly
✅ **Deferred Work Completion:** No deferred work for this task (no following.md exists)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, boolean transformation, cross-field dependencies, nested structure)
✅ **Proof Document Quality:** Excellent - all required sections present, Go code evidence provided, no forbidden phrases

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The cross-variable validations correctly use Terraform 1.9+ cross-variable validation in variables.tf validation blocks. The boolean-to-string transformation matches the provider's expand function exactly. All CustomizeDiff validations have been replicated with exact error messages.

**Status:** APPROVED ✅

---
