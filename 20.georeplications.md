# Task #20 - georeplications Block Structure Skeleton - PROOF DOCUMENT

## Summary

Created structure skeleton for the `georeplications` block. This block is implemented as a post-creation operation since georeplications are managed as separate child resources (`Microsoft.ContainerRegistry/registries/replications`) in Azure API. The skeleton includes conditional logic and placeholders for child tasks #21-24.

## Create Phase Verification

### Pattern Identification

Queried the Create method from `container_registry_resource.go`:

```go
func resourceContainerRegistryCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ... primary registry creation ...
    
    if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
        return fmt.Errorf("creating %s: %+v", id, err)
    }

    // the ACR is being created so no previous geo-replication locations
    var oldGeoReplicationLocations, newGeoReplicationLocations []replications.Replication
    newGeoReplicationLocations = expandReplications(d.Get("georeplications").([]interface{}))
    // geo replications have been specified
    if len(newGeoReplicationLocations) > 0 {
        err = applyGeoReplicationLocations(ctx, meta, id, oldGeoReplicationLocations, newGeoReplicationLocations)
        if err != nil {
            return fmt.Errorf("applying geo replications for %s: %+v", id, err)
        }
    }

    d.SetId(id.ID())

    return resourceContainerRegistryRead(d, meta)
}
```

### SDK Function Identification

The `applyGeoReplicationLocations` function uses `replicationClient.CreateThenPoll`:

```go
func applyGeoReplicationLocations(ctx context.Context, meta interface{}, registryId registries.RegistryId, oldGeoReplications []replications.Replication, newGeoReplications []replications.Replication) error {
    replicationClient := meta.(*clients.Client).Containers.ContainerRegistryClient.Replications
    log.Printf("[INFO] preparing to apply geo-replications for Container Registry.")

    // ... logic to compare old and new ...
    
    // Create replications that only exists in the new locations.
    for loc, repl := range newReplications {
        if _, ok := oldReplications[loc]; ok {
            continue
        }
        id := replications.NewReplicationID(registryId.SubscriptionId, registryId.ResourceGroupName, registryId.RegistryName, loc)
        if err := replicationClient.CreateThenPoll(ctx, id, repl); err != nil {
            return fmt.Errorf("creating %s: %+v", id, err)
        }
    }
    // ... update and delete logic ...
}
```

**Pattern:** Multi-phase create operation
- **Phase 1:** Primary registry creation via `client.CreateThenPoll` (main resource)
- **Phase 2:** Georeplications creation via `replicationClient.CreateThenPoll` (child resources of different type)

### Classification Decision

**Field Classification:** Post-creation operation (Type 5)
- **SDK Function Type:** `CreateThenPoll` (CreateOrUpdate pattern)
- **Index:** `post_creation0` (first post-creation operation, index 0)
- **Resource Type:** `Microsoft.ContainerRegistry/registries/replications@2025-04-01` (different from main resource type)

**Evidence:**
1. Georeplications are created AFTER the primary `CreateThenPoll` completes
2. Uses different SDK client (`replicationClient` vs `client`)
3. Creates separate child resources with different type and name
4. Each georeplication has its own resource ID: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/registries/{registryName}/replications/{replicationName}`

## Assignment Path Verification

### Predicted Path

For georeplications post-creation operation:
```
post_creation0 → azapi_resource (child) → body → properties → {fields}
```

Each replication is a separate child resource with:
- `location`: Root level (azapi_resource parameter)
- `tags`: Root level (azapi_resource parameter)
- `properties.zoneRedundancy`: Body properties
- `properties.regionEndpointEnabled`: Body properties

### Go Code Evidence

From `expandReplications` function (lines 1112-1134):

```go
func expandReplications(p []interface{}) []replications.Replication {
    reps := make([]replications.Replication, 0)
    if p == nil {
        return reps
    }
    for _, v := range p {
        value := v.(map[string]interface{})
        location := location.Normalize(value["location"].(string))
        tags := tags.Expand(value["tags"].(map[string]interface{}))
        zoneRedundancy := replications.ZoneRedundancyDisabled
        if value["zone_redundancy_enabled"].(bool) {
            zoneRedundancy = replications.ZoneRedundancyEnabled
        }
        reps = append(reps, replications.Replication{
            Location: location,                           // <- Direct assignment to Location (root level)
            Name:     &location,                          // <- Name is location
            Tags:     tags,                               // <- Direct assignment to Tags (root level)
            Properties: &replications.ReplicationProperties{
                ZoneRedundancy:        &zoneRedundancy,        // <- .Properties.ZoneRedundancy
                RegionEndpointEnabled: pointer.To(value["regional_endpoint_enabled"].(bool)),  // <- .Properties.RegionEndpointEnabled
            },
        })
    }
    return reps
}
```

### Verified Path

```
replications.Replication struct:
  .Location → azapi_header.location (root level parameter)
  .Name → azapi_header.name (root level parameter, equals location)
  .Tags → azapi_header.tags (root level parameter)
  .Properties.ZoneRedundancy → body.properties.zoneRedundancy
  .Properties.RegionEndpointEnabled → body.properties.regionEndpointEnabled
```

### Path Comparison

**Match:** ✅ Paths match the expected structure

The structure requires multiple child `azapi_resource` instances (one per georeplication location), implemented via `for` loop in post-creation operation.

## Provider Schema

From `container_registry_resource.go` (lines 92-123):

```go
"georeplications": {
    // Don't make this a TypeSet since TypeSet has bugs when there is a nested property using `StateFunc`.
    // See: https://github.com/hashicorp/terraform-plugin-sdk/issues/160
    Type:       pluginsdk.TypeList,
    Optional:   true,
    ConfigMode: pluginsdk.SchemaConfigModeAuto,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "location": commonschema.LocationWithoutForceNew(),

            "zone_redundancy_enabled": {
                Type:     pluginsdk.TypeBool,
                Optional: true,
                Default:  false,
            },

            "regional_endpoint_enabled": {
                Type:     pluginsdk.TypeBool,
                Optional: true,
            },

            "tags": commonschema.Tags(),
        },
    },
},
```

**Schema Properties:**
- **Type:** `TypeList` (not TypeSet, due to SDK limitations)
- **Optional:** Yes
- **ConfigMode:** `SchemaConfigModeAuto`
- **Child Fields:**
  - `location`: Required (LocationWithoutForceNew)
  - `zone_redundancy_enabled`: Optional, Default: false
  - `regional_endpoint_enabled`: Optional
  - `tags`: Optional

## Azure API Schema

### Resource Type

`Microsoft.ContainerRegistry/registries/replications@2025-04-01`

### Schema Structure

From Azure API documentation:

```json
{
  "location": "string (Required)",
  "name": "string (Required)",
  "tags": {},
  "properties": {
    "regionEndpointEnabled": "boolean",
    "zoneRedundancy": "string (Possible values: Enabled, Disabled)"
  }
}
```

**Key Points:**
1. Each replication is a **separate child resource**
2. Parent ID format: `/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.ContainerRegistry/registries/{registryName}`
3. Replication ID format: `{parentId}/replications/{locationName}`
4. The replication `name` is the normalized location string
5. `zoneRedundancy` is a string enum ("Enabled"/"Disabled"), not boolean

## Hidden Fields

### Check Expand Function for Hidden Fields

From `expandReplications` function:

```go
reps = append(reps, replications.Replication{
    Location: location,
    Name:     &location,  // <- HIDDEN: Name is automatically set to location
    Tags:     tags,
    Properties: &replications.ReplicationProperties{
        ZoneRedundancy:        &zoneRedundancy,
        RegionEndpointEnabled: pointer.To(value["regional_endpoint_enabled"].(bool)),
    },
})
```

**Hidden Field Identified:**
- `Name`: Automatically set to the normalized location string (not exposed in schema)

This is NOT a hidden field in the body - it's the resource name derived from location. Will be handled in implementation via `name = location` in `azapi_header`.

### No Additional Hidden Fields

No additional hidden fields found in expand function beyond the standard documented fields.

## Mapping (snake_case → camelCase)

| Terraform (snake_case) | Azure API (camelCase) | Level |
|------------------------|----------------------|-------|
| location | location | azapi_header (root) |
| tags | tags | azapi_header (root) |
| zone_redundancy_enabled | properties.zoneRedundancy | body |
| regional_endpoint_enabled | properties.regionEndpointEnabled | body |

**Special Handling:**
- `zone_redundancy_enabled` (bool) → `zoneRedundancy` (string: "Enabled"/"Disabled")

## Special Handling

### 1. Post-Creation Operation (Type 5)

**Classification:** `post_creation0`
- **Reason:** Created AFTER primary registry resource
- **SDK Function:** `CreateThenPoll` (child resource creation)
- **Resource Type:** `Microsoft.ContainerRegistry/registries/replications@2025-04-01`

### 2. ForceNew Analysis

**No ForceNew Required for the Block:**
The georeplications list itself is updatable. Individual replications are managed via:
- **Add:** New locations → Create new replication child resources
- **Remove:** Deleted locations → Delete replication child resources  
- **Update:** Changed properties → Update or replace specific replication

**Per-Replication ForceNew (Handled in Implementation):**
From `applyGeoReplicationLocations` function (lines 868-926):

```go
// Compare old and new replication parameters to see whether it has updated.
// If there no update, then skip it. Otherwise, need to check whether the update
// can happen in place, or need a recreation.

var (
    needUpdate  bool
    needReplace bool
)
// Since the replications here are all derived from expand function, where we guaranteed
// each properties are non-nil. Whilst we are still doing nil check here in case.
if oprop, nprop := oldRepl.Properties, newRepl.Properties; oprop != nil && nprop != nil {
    // zoneRedundency can't be updated in place
    if ov, nv := oprop.ZoneRedundancy, nprop.ZoneRedundancy; ov != nil && nv != nil && *ov != *nv {
        needUpdate = true
        needReplace = true  // <- zone_redundancy_enabled change requires REPLACEMENT
    }
    if ov, nv := oprop.RegionEndpointEnabled, nprop.RegionEndpointEnabled; ov != nil && nv != nil && *ov != *nv {
        needUpdate = true  // <- regional_endpoint_enabled can be updated in place
    }
}
```

**ForceNew Logic:**
- `zone_redundancy_enabled`: Changes trigger DELETE + CREATE (replacement)
- `regional_endpoint_enabled`: Can be updated in place
- `tags`: Can be updated in place

**Implementation Note:** This ForceNew logic will be implemented in child tasks (Task #24 for `zone_redundancy_enabled`).

### 3. Validation Requirements

**Already Implemented in variables.tf:**
No additional validations needed for the block structure itself. Individual field validations will be handled by child tasks.

**Existing Cross-Field Validation (from CustomizeDiff, lines 294-298):**

```go
geoReplications := d.Get("georeplications").([]interface{})
// if locations have been specified for geo-replication then, the SKU has to be Premium
if len(geoReplications) > 0 && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR geo-replication can only be applied when using the Premium Sku")
}
```

This validation is already implemented in Task #4 (sku variable validation in variables.tf).

**Location Uniqueness Validation (lines 301-312):**

```go
// ensure location is different than any location of the geo-replication
var geoReplicationLocations []string
for _, v := range geoReplications {
    v := v.(map[string]interface{})
    geoReplicationLocations = append(geoReplicationLocations, location.Normalize(v["location"].(string)))
}
location := location.Normalize(d.Get("location").(string))
for _, loc := range geoReplicationLocations {
    if loc == location {
        return errors.New("the `georeplications` list cannot contain the location where the Container Registry exists")
    }
}
```

**Deferral:** This cross-field validation between `location` and `georeplications[*].location` will be deferred to Task #21 (georeplications.location) since it references the location field owned by that task.

### 4. Sensitive Fields

**None.** No sensitive or write-only fields in georeplications block.

### 5. Multiple Child Resources Pattern

Unlike typical blocks that map to a single nested object, georeplications maps to **multiple separate child resources**. Implementation approach:

**Structure:** Use `for` expression to create list of replication configurations:

```hcl
locals {
  post_creation0 = var.georeplications != null && length(var.georeplications) > 0 ? [
    for idx, repl in var.georeplications : {
      azapi_header = {
        type      = "Microsoft.ContainerRegistry/registries/replications@2025-04-01"
        name      = repl.location
        location  = repl.location
        parent_id = azapi_resource.this.id  # Reference to main registry
        tags      = repl.tags
        ignore_null_property = true
        retry = null
      }
      body = {
        properties = {
          # zoneRedundancy = ... # Task #24
          # regionEndpointEnabled = ... # Task #22
        }
      }
      locks = local.locks
    }
  ] : null
}
```

**Note:** Changed from object to list since we have multiple child resources (one per location).

## Shadow Implementation

```hcl
# ===== migrate_main.tf =====

locals {
  # ... existing locals ...
  
  # Post-creation operations - georeplications
  # Each georeplication is a separate child resource (Microsoft.ContainerRegistry/registries/replications)
  post_creation0 = var.georeplications != null && length(var.georeplications) > 0 ? [  # <-
    for idx, repl in var.georeplications : {  # <-
      azapi_header = {  # <-
        type                 = "Microsoft.ContainerRegistry/registries/replications@2025-04-01"  # <-
        name                 = repl.location  # <- Hidden field: name equals location
        location             = repl.location  # <- Task #21 will uncomment
        parent_id            = azapi_resource.this.id  # <- Reference to main registry resource
        tags                 = repl.tags  # <- Task #23 will uncomment
        ignore_null_property = true  # <-
        retry                = null  # <-
      }  # <-
      body = {  # <-
        properties = {  # <-
          # zoneRedundancy = ... # Task #24
          # regionEndpointEnabled = ... # Task #22
        }  # <-
      }  # <-
      locks = local.locks  # <-
    }  # <-
  ] : null  # <-
  
  post_creation0_sensitive_body = null  # <- No sensitive fields in georeplications
}

# ===== migrate_outputs.tf =====

output "post_creation0" {  # <-
  value = local.post_creation0  # <-
}  # <-

output "post_creation0_sensitive_body" {  # <-
  value = local.post_creation0_sensitive_body  # <-
}  # <-
```

## Deferred Work Completion

Checked `following.md` - file does not exist, no deferred work to complete.

## Critical Review & Edge Cases

### Edge Case Analysis

**1. Null Semantics**
- **`var.georeplications = null`**: No replications created → `post_creation0 = null`
- **`var.georeplications = []`**: Empty list, no replications created → `post_creation0 = null` (length check)

**2. Empty Collections**
- Empty list (`[]`) → `length(var.georeplications) > 0` is `false` → `post_creation0 = null` ✅

**3. Boundary Conditions**
- **Single replication:** Creates one child resource ✅
- **Multiple replications:** Creates multiple child resources via `for` loop ✅
- **Location normalization:** Handled by child task #21

**4. Idempotency**
- List order matters in provider (uses TypeList not TypeSet)
- For loop preserves order from input list ✅
- Parent resource reference (`azapi_resource.this.id`) ensures proper dependency ✅

**5. Safe References**
- Check `var.georeplications != null` before `length()` ✅
- Check `length(var.georeplications) > 0` before `for` loop ✅
- Reference to `azapi_resource.this.id` is safe (main resource always exists when post_creation runs)

**6. Special Considerations**

**Location Matching:** Main registry location cannot appear in georeplications list (validation in CustomizeDiff). This validation will be implemented in Task #21.

**Replication Management:** 
- Add location: Creates new child resource
- Remove location: Deletes child resource
- Update properties: Updates or replaces (depending on which property changes)

**Name = Location:** The replication resource name is always the location (normalized). This is automatically handled by setting `name = repl.location` in `azapi_header`.

## Child Task Status

After completing this task, the following child tasks are now **READY for delegation**:

| Task # | Field | Type | Status |
|--------|-------|------|--------|
| 21 | georeplications.location | Argument | ✅ READY - skeleton exists |
| 22 | georeplications.regional_endpoint_enabled | Argument | ✅ READY - skeleton exists |
| 23 | georeplications.tags | Argument | ✅ READY - skeleton exists |
| 24 | georeplications.zone_redundancy_enabled | Argument | ✅ READY - skeleton exists |

**All child tasks can now be executed in parallel** since the parent block structure is complete.

## Checklist

- ✅ Block skeleton created with conditional logic
- ✅ Comment placeholders added for all child fields (Tasks #21-24)
- ✅ Post-creation pattern identified (Type 5, `post_creation0`)
- ✅ Resource type identified: `Microsoft.ContainerRegistry/registries/replications@2025-04-01`
- ✅ Hidden field documented: `name` = `location`
- ✅ ForceNew analysis completed (per-field logic deferred to Task #24)
- ✅ Validation deferred to Task #21 (location uniqueness check)
- ✅ No sensitive fields
- ✅ Edge case analysis completed
- ✅ Child tasks listed as ready for delegation
- ✅ Multiple child resources pattern documented (list of resources via `for` loop)
- ✅ Output declarations added for `post_creation0` and `post_creation0_sensitive_body`
- ✅ Proof document created
- ✅ Ready to update track.md

## Self-Review

**Content Added:**
- ✅ Post-creation operation structure (`post_creation0`) with list pattern
- ✅ Output declarations for post_creation0
- ✅ Comment placeholders for child tasks only

**No Extra Content:**
- ✅ Did NOT implement individual field logic (Tasks #21-24)
- ✅ Did NOT add validations (deferred to Task #21)
- ✅ Did NOT add hidden fields to body (documented only)

**Scope Verification:** ✅ All changes are within Task #20 scope.

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #20 - georeplications

### Issues Identified

#### Issue 1: Invalid Reference to azapi_resource.this.id

**Problem:**
Executor used `parent_id = azapi_resource.this.id` in the post_creation0 structure (line 89 of original migrate_main.tf). This is architecturally impossible because:
- The shadow module (migrate_* files) only produces **locals/outputs**
- The actual `azapi_resource.this` resource is created in the **root module** (main.tf), not in migrate_main.tf
- Shadow module cannot reference resources from the root module that don't exist in its scope

**Executor's Implementation:**
```hcl
parent_id = azapi_resource.this.id # Reference to main registry resource
```

**Why This Violates executor.md:**
From executor.md context: "Your locals feed root module's `azapi_resource`". The migrate files are building data structures (locals) that will be consumed by main.tf. They cannot reference back to resources created by main.tf.

**Provider's Actual Behavior:**
From the Go code, replication parent ID format is:
```go
id := replications.NewReplicationID(registryId.SubscriptionId, registryId.ResourceGroupName, registryId.RegistryName, loc)
// Format: /subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.ContainerRegistry/registries/{registryName}/replications/{location}
```

The parent portion is: `/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.ContainerRegistry/registries/{registryName}`

**Expected Behavior:**
Parent ID must be constructed from available variables:
- `var.resource_group_id` = `/subscriptions/{sub}/resourceGroups/{rg}`
- `var.name` = registry name
- Result: `"${var.resource_group_id}/providers/Microsoft.ContainerRegistry/registries/${var.name}"`

**Root Cause:**
Executor misunderstood the shadow module architecture and attempted to reference a resource that doesn't exist in the migrate_main.tf scope.

#### Issue 2: Incorrectly Commented azapi_header Fields

**Problem:**
Lines 88 and 90 had commented assignments with comments suggesting child tasks would uncomment them:

```hcl
location             = repl.location # Task #21
tags                 = repl.tags # Task #23
```

**Why This Violates executor.md:**
These assignments are part of the **block structure skeleton** (Task #20's responsibility), not field implementations. The data is already available from `repl.location` and `repl.tags` - these are simple pass-through assignments that complete the azapi_header structure.

**What Child Tasks Actually Do:**
- **Task #21 (location):** Implement location **validation**, and handle location in body.properties if needed by Azure API
- **Task #23 (tags):** Implement tags **validation**, and handle tags in body.properties if needed by Azure API

The azapi_header assignments are **structural** and must be completed in the skeleton task (Task #20).

**Expected Behavior:**
Both assignments should be active (uncommented) as part of the skeleton implementation. Child tasks will add validations and body logic, not uncomment skeleton structure.

### Corrections Made

#### Fix 1: Correct parent_id Construction

**Changed Files:**
- `migrate_main.tf`: Fixed parent_id in post_creation0 structure

**New Implementation:**
```hcl
parent_id = "${var.resource_group_id}/providers/Microsoft.ContainerRegistry/registries/${var.name}"
```

**Why This is EXACT:**
This constructs the correct parent resource ID from available variables:
1. Uses `var.resource_group_id` which has format `/subscriptions/{sub}/resourceGroups/{rg}`
2. Appends the provider namespace and resource type: `/providers/Microsoft.ContainerRegistry/registries/`
3. Appends the registry name from `var.name`
4. Results in exact format: `/subscriptions/{sub}/resourceGroups/{rg}/providers/Microsoft.ContainerRegistry/registries/{registryName}`

**Verification:**
- Scenario 1: resource_group_id = `/subscriptions/abc/resourceGroups/rg1`, name = `myregistry` → parent_id = `/subscriptions/abc/resourceGroups/rg1/providers/Microsoft.ContainerRegistry/registries/myregistry` ✅
- Edge Case: Proper string interpolation, no resource reference issues ✅

#### Fix 2: Uncomment azapi_header Structural Fields

**Changed Files:**
- `migrate_main.tf`: Removed comments from location and tags assignments

**New Implementation:**
```hcl
location             = repl.location
tags                 = repl.tags
```

**Why This is EXACT:**
1. These are pass-through assignments from the georeplications list structure
2. Part of skeleton's responsibility to complete azapi_header structure
3. Child tasks (#21, #23) will add **validations** for these fields, not uncomment them
4. Matches executor.md pattern for Type 3 tasks: "Create skeleton ONLY" but complete structural assignments

**Verification:**
- Scenario 1: repl with location and tags → azapi_header populated correctly ✅
- Scenario 2: Child tasks will add validations independently ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:
- Post-creation pattern correctly identified and implemented
- Multiple child resources correctly handled via list structure
- Parent ID correctly constructed from available variables
- All structural assignments completed in skeleton task
- No invalid resource references

**Status:** CORRECTED AND APPROVED ✅

---
