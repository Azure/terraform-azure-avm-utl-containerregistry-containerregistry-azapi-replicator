# Task #32: network_rule_set.ip_rule.ip_range

## Summary
Implemented the `ip_range` argument for the `network_rule_set.ip_rule` block. This field specifies the CIDR block from which requests will match the rule. The provider validates the value as a valid IPv4 CIDR notation, maps it to Azure API's `value` field, and handles a special case where Azure drops /32 suffix for single IP addresses.

## Shadow Implementation

```hcl
# In migrate_main.tf - within local.body.properties.networkRuleSet.ipRules array
for rule in var.network_rule_set[0].ip_rule : {
  action = rule.action
  value  = rule.ip_range  # <-
}

# In variables.tf - validation block added to network_rule_set variable
validation {  # <-
  condition = var.network_rule_set == null || length(var.network_rule_set) == 0 || alltrue([  # <-
    for nrs in var.network_rule_set :  # <-
    nrs.ip_rule == null || alltrue([  # <-
      for rule in nrs.ip_rule :  # <-
      can(regex("^([0-9]{1,3}\\.){3}[0-9]{1,3}(/([0-9]|[1-2][0-9]|3[0-2]))?$", rule.ip_range))  # <-
    ])  # <-
  ])  # <-
  error_message = "ip_rule.ip_range must start with IPv4 address and/or slash, number of bits (0-32) as prefix. Example: 127.0.0.1/8"  # <-
}  # <-
```

## Create Phase Verification

### Provider Create Method Evidence

**Query:** GitHub source code analysis of `resourceContainerRegistryCreate` function

**expandNetworkRuleSet Function Call (Line 449):**
```go
networkRuleSet := expandNetworkRuleSet(d.Get("network_rule_set").([]interface{}))
```

**Primary Create Operation (Lines 493-510):**
```go
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    Identity: identity,
    Properties: &registries.RegistryProperties{
        AdminUserEnabled: pointer.To(d.Get("admin_enabled").(bool)),
        Encryption:       expandEncryption(d.Get("encryption").([]interface{})),
        NetworkRuleSet:   networkRuleSet,  // <- ip_rule (including ip_range) included here
        // ...
    },
    Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
}

if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**Pattern:** Single-phase creation with one `CreateThenPoll` operation.

**Classification:** `network_rule_set.ip_rule.ip_range` is processed during the **Create phase** (included in primary `CreateThenPoll` operation). The field belongs in `local.body.properties.networkRuleSet.ipRules[].value`.

**Decision:** Implement the field in `local.body.properties.networkRuleSet.ipRules` array within the for-expression, mapping `rule.ip_range` to `value`.

## Assignment Path Verification

### Predicted Path
`body.properties.networkRuleSet.ipRules[].value`

### Go Code Evidence

**expandNetworkRuleSet Function (Lines 1046-1065):**
```go
func expandNetworkRuleSet(profiles []interface{}) *registries.NetworkRuleSet {
    if len(profiles) == 0 {
        return nil
    }

    profile := profiles[0].(map[string]interface{})

    ipRuleConfigs := profile["ip_rule"].(*pluginsdk.Set).List()
    ipRules := make([]registries.IPRule, 0)
    for _, ipRuleInterface := range ipRuleConfigs {
        config := ipRuleInterface.(map[string]interface{})
        newIpRule := registries.IPRule{
            Action: pointer.To(registries.Action(config["action"].(string))),
            Value:  config["ip_range"].(string),  // <- ip_range mapped to Value field
        }
        ipRules = append(ipRules, newIpRule)
    }

    return &registries.NetworkRuleSet{
        DefaultAction: registries.DefaultAction(profile["default_action"].(string)),
        IPRules:       &ipRules,  // <- Assigned to IPRules field
    }
}
```

**Struct Assignment in Create (Line 510):**
```go
NetworkRuleSet:   networkRuleSet,  // <- Assigned to Properties.NetworkRuleSet
```

**Path Trace:**
1. `expandNetworkRuleSet` creates `registries.NetworkRuleSet` with `IPRules` field
2. Each `IPRule` has `Value` field set from `config["ip_range"]`
3. The struct is assigned to `parameters.Properties.NetworkRuleSet`
4. Final path: `body.properties.networkRuleSet.ipRules[].value`

### Verified Path
`body.properties.networkRuleSet.ipRules[].value`

### Path Comparison
✅ **Match**: Predicted path matches actual assignment path.

## Provider Schema

**Schema Definition (Lines 186-189):**
```go
"ip_range": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: validate.CIDR,
},
```

**Key Properties:**
- **Type:** String
- **Required:** true
- **ValidateFunc:** validate.CIDR (IPv4 CIDR validation)
- **No ForceNew:** Changes are allowed
- **No Sensitive:** Plain value
- **No DiffSuppressFunc:** No diff suppression

**validate.CIDR Function (helpers/validate/network.go):**
```go
func CIDR(i interface{}, k string) (warnings []string, errors []error) {
    cidr := i.(string)

    re := regexp.MustCompile(`^([0-9]{1,3}\.){3}[0-9]{1,3}(/([0-9]|[1-2][0-9]|3[0-2]))?$`)
    if re != nil && !re.MatchString(cidr) {
        errors = append(errors, fmt.Errorf("%s must start with IPV4 address and/or slash, number of bits (0-32) as prefix. Example: 127.0.0.1/8. Got %q", k, cidr))
    }

    return warnings, errors
}
```

**Validation Logic:**
- Validates IPv4 CIDR notation
- Format: `xxx.xxx.xxx.xxx` or `xxx.xxx.xxx.xxx/yy`
- Each octet: 1-3 digits (0-999, though semantically 0-255)
- Prefix length: 0-32
- Examples: `192.168.1.0/24`, `10.0.0.1/32`, `172.16.0.0/16`

## Azure API Schema

**Query:** `query_azapi_resource_schema(resource_type="Microsoft.ContainerRegistry/registries", api_version="2025-04-01", path="body.properties.networkRuleSet.ipRules")`

**Result:**
```
List(ObjectWithOptionalAttrs(map[string]Type{"action":String, "value":String}, []string{"action"}))
```

**Interpretation:**
- Type: Array of objects
- Fields per object:
  - `action`: String (required)
  - `value`: String (optional per API, but provider makes it required)

**API Field Name Mapping:**
- Provider `ip_range` → API `value`

## Hidden Fields

### Check expandNetworkRuleSet for Hidden Logic

**expandNetworkRuleSet Function (Lines 1046-1065):**
```go
for _, ipRuleInterface := range ipRuleConfigs {
    config := ipRuleInterface.(map[string]interface{})
    newIpRule := registries.IPRule{
        Action: pointer.To(registries.Action(config["action"].(string))),
        Value:  config["ip_range"].(string),  // <- Direct mapping, no transformation
    }
    ipRules = append(ipRules, newIpRule)
}
```

**Analysis:**
- No transformation applied to ip_range value
- No hardcoded values added
- No defaults applied
- Direct string assignment from user input

**Conclusion:** ✅ **No hidden fields or transformations** detected in expand function.

### Check flattenNetworkRuleSet for Special Handling

**flattenNetworkRuleSet Function (Lines 1156-1177):**
```go
func flattenNetworkRuleSet(networkRuleSet *registries.NetworkRuleSet) []interface{} {
    if networkRuleSet == nil {
        return []interface{}{}
    }

    values := make(map[string]interface{})
    values["default_action"] = string(networkRuleSet.DefaultAction)

    ipRules := make([]interface{}, 0)
    for _, ipRule := range *networkRuleSet.IPRules {
        value := make(map[string]interface{})
        value["action"] = string(*ipRule.Action)

        // When a /32 CIDR is passed as an ip rule, Azure will drop the /32 leading to the resource wanting to be re-created next run
        if !strings.Contains(ipRule.Value, "/") {
            ipRule.Value += "/32"
        }

        value["ip_range"] = ipRule.Value
        ipRules = append(ipRules, value)
    }

    values["ip_rule"] = ipRules
    return []interface{}{values}
}
```

**Special Handling - /32 Suffix:**
- When Azure API receives `x.x.x.x/32`, it may return `x.x.x.x` (without /32)
- Provider adds `/32` back during Read to normalize single IP addresses
- This prevents unnecessary resource recreation on next apply
- Example: User sets `192.168.1.1/32` → Azure stores `192.168.1.1` → Provider reads as `192.168.1.1/32`

**Impact on Replicator:**
This is a **Read-phase normalization** that prevents spurious diffs. Since we're using AzAPI provider which handles state comparison differently, and since the CIDR validation allows both formats (`x.x.x.x` and `x.x.x.x/32`), this normalization is handled by:
1. Terraform's state comparison (comparing user input vs. API response)
2. The CIDR validation accepting both formats
3. No special handling needed in our replicator code

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**
- `ip_range` → `value`

## Special Handling

### No ForceNew
The `ip_range` field does **NOT** have `ForceNew: true` in the provider schema. This means changes to ip_range values are applied via Update operations, not resource replacement.

**No action needed:** Field is not added to `replace_triggers_external_values`.

### No Sensitive
The `ip_range` field is **NOT** marked as `Sensitive: true`. IP address ranges are not considered sensitive information.

**No action needed:** Field is placed in `body`, not `sensitive_body`.

### Validation Implementation

**Provider Validation:**
- ValidateFunc: `validate.CIDR`
- Regex: `^([0-9]{1,3}\.){3}[0-9]{1,3}(/([0-9]|[1-2][0-9]|3[0-2]))?$`
- Validates IPv4 CIDR notation with optional prefix length

**Replicator Implementation:**
Added validation block to `network_rule_set` variable in `variables.tf`:

```hcl
validation {
  condition = var.network_rule_set == null || length(var.network_rule_set) == 0 || alltrue([
    for nrs in var.network_rule_set :
    nrs.ip_rule == null || alltrue([
      for rule in nrs.ip_rule :
      can(regex("^([0-9]{1,3}\\.){3}[0-9]{1,3}(/([0-9]|[1-2][0-9]|3[0-2]))?$", rule.ip_range))
    ])
  ])
  error_message = "ip_rule.ip_range must start with IPv4 address and/or slash, number of bits (0-32) as prefix. Example: 127.0.0.1/8"
}
```

**Validation Logic:**
1. Check if `network_rule_set` is null or empty - if so, skip validation
2. For each network_rule_set element, check if `ip_rule` is null - if so, skip validation
3. For each ip_rule, validate that `ip_range` matches the CIDR regex pattern
4. Use `can(regex(...))` to safely test the pattern without causing errors

**Exact Replication:** ✅ The regex pattern and validation logic exactly match the provider's `validate.CIDR` function.

## Deferred Work Completion

**Check following.md:** File does not exist - no deferred work to complete.

## Critical Review & Edge Case Analysis

### Edge Case 1: Valid CIDR Formats

**Scenario 1:** `ip_range = "192.168.1.0/24"` (network address with prefix)

**Behavior:**
- Validation passes (matches regex)
- Value passed to API: `"192.168.1.0/24"`
- Azure accepts and stores

**Correctness:** ✅ Standard CIDR notation

**Scenario 2:** `ip_range = "10.0.0.1/32"` (single IP with /32)

**Behavior:**
- Validation passes (matches regex)
- Value passed to API: `"10.0.0.1/32"`
- Azure may return `"10.0.0.1"` (without /32) in Read
- Provider's flatten function adds `/32` back for consistency

**Correctness:** ✅ Valid format, /32 handling is Read-phase concern

**Scenario 3:** `ip_range = "172.16.0.1"` (single IP without prefix)

**Behavior:**
- Validation passes (regex allows optional prefix: `(/...)?`)
- Value passed to API: `"172.16.0.1"`
- Azure treats as single IP
- Provider's flatten may add `/32` for normalization

**Correctness:** ✅ Validation allows both formats

### Edge Case 2: Invalid Formats

**Scenario 1:** `ip_range = "256.1.1.1/24"` (invalid octet)

**Behavior:**
- Validation PASSES regex (regex checks syntax, not semantic validity)
- Azure API will reject (400 Bad Request)

**Trade-off:**
- Provider's validation also passes syntax check only
- Azure API performs semantic validation (octet range 0-255)
- **Exact replication of provider behavior** ✅

**Scenario 2:** `ip_range = "192.168.1.0/33"` (invalid prefix length)

**Behavior:**
- Validation FAILS (regex requires 0-32: `[0-9]|[1-2][0-9]|3[0-2]`)
- Error at plan time: "ip_rule.ip_range must start with IPv4 address..."

**Correctness:** ✅ Caught by validation

**Scenario 3:** `ip_range = "not-an-ip"` (invalid format)

**Behavior:**
- Validation FAILS (doesn't match IPv4 pattern)
- Error at plan time: "ip_rule.ip_range must start with IPv4 address..."

**Correctness:** ✅ Caught by validation

### Edge Case 3: Null Handling

**Scenario:** `ip_range` field is Required, cannot be null within ip_rule object

**Type System Enforcement:**
```hcl
ip_rule = set(object({
  action   = string
  ip_range = string  # <- Required string, cannot be null
}))
```

**Behavior:**
- Terraform enforces non-null constraint at type level
- If user tries `ip_range = null`, Terraform errors before validation

**Correctness:** ✅ Type system prevents null values

### Edge Case 4: Empty String

**Scenario:** `ip_range = ""`

**Behavior:**
- Validation FAILS (empty string doesn't match IPv4 pattern)
- Error at plan time: "ip_rule.ip_range must start with IPv4 address..."

**Correctness:** ✅ Empty strings are invalid CIDR, properly rejected

### Edge Case 5: Whitespace

**Scenario:** `ip_range = " 192.168.1.0/24 "` (leading/trailing spaces)

**Behavior:**
- Validation FAILS (regex is anchored with `^` and `$`, requires exact match)
- Error at plan time

**Provider Behavior:** Provider also rejects whitespace (regex match without trimming)

**Correctness:** ✅ Exact replication of provider behavior

### Edge Case 6: Set Deduplication

**Scenario:** User provides duplicate ip_range values in the set

```hcl
ip_rule = [
  { action = "Allow", ip_range = "10.0.0.0/24" },
  { action = "Allow", ip_range = "10.0.0.0/24" }  # Duplicate
]
```

**Behavior:**
- Terraform's `set` type automatically deduplicates
- Only one rule sent to API
- For-expression iterates over deduplicated set

**Correctness:** ✅ Set semantics maintained

### Safe References

**All array accesses are safe:**

1. ✅ `var.network_rule_set[0].ip_rule` - Safe: Already inside condition checking `var.network_rule_set != null && length(var.network_rule_set) > 0` (from Task #28)
2. ✅ `rule.ip_range` - Safe: `rule` is loop variable from `for rule in var.network_rule_set[0].ip_rule`, only executed when ip_rule is not null and has elements

**Validation condition structure is safe:**
```hcl
var.network_rule_set == null || length(var.network_rule_set) == 0 || alltrue([
  for nrs in var.network_rule_set :
  nrs.ip_rule == null || alltrue([
    for rule in nrs.ip_rule :
    can(regex(..., rule.ip_range))  # <- Safe: only evaluated when rule exists
  ])
])
```

**Short-circuit evaluation:**
- If `network_rule_set` is null, validation passes immediately
- If `network_rule_set` is empty, validation passes immediately
- If `ip_rule` is null, validation passes for that network_rule_set
- Only evaluates `rule.ip_range` when rule definitely exists

### Idempotency

**Test:** Apply twice with same ip_rule configuration

**Expected:** No changes detected on second apply

**Analysis:**
1. Set ensures no duplicate rules
2. For-expression produces consistent output for same input
3. Azure API compares rules by content (action + value)
4. Order doesn't matter (set semantics)
5. /32 normalization handled by provider's Read function

**Correctness:** ✅ Idempotent behavior maintained

## Checklist

- ✅ Property in correct local (`body.properties.networkRuleSet.ipRules[].value`)
- ✅ Field mapped correctly (ip_range → value)
- ✅ Validation IMPLEMENTED in variables.tf (CIDR regex validation)
- ✅ Validation exactly replicates provider's validate.CIDR function
- ✅ No ForceNew (field not added to replace_triggers_external_values)
- ✅ Not sensitive (field in body, not sensitive_body)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work from following.md: None (file doesn't exist)
- ✅ Critical review (null safety, validation, edge cases)
- ✅ Edge Case Analysis in proof (CIDR formats, invalid inputs, whitespace, deduplication)
- ✅ Safe references verified (all protected by conditionals)
- ✅ Idempotency verified (set semantics + consistent output)
- ✅ Proof created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Only implemented ip_range field (Task #32); no content from other tasks added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #32 - network_rule_set.ip_rule.ip_range

### Validation Results

✅ **ForceNew Logic:** N/A (field does not have ForceNew: true in provider schema)
✅ **Stable Keys:** N/A (field not added to replace_triggers_external_values)
✅ **Phase Detection:** Field correctly placed in local.body (Create phase, included in primary CreateThenPoll operation)
✅ **Type Conversion:** Correct mapping from Terraform string type to Azure API string type
✅ **Assignment Path:** Correctly verified as body.properties.networkRuleSet.ipRules[].value
✅ **Null Handling:** Correctly propagates null semantics with conditional checks (ip_rule != null && length(ip_rule) > 0)
✅ **Validations:** Provider's validate.CIDR function exactly replicated in variables.tf validation block
✅ **Validation Method:** Correctly implemented in variables.tf (not deferred to Azure API)
✅ **Regex Pattern:** Identical to provider: `^([0-9]{1,3}\.){3}[0-9]{1,3}(/([0-9]|[1-2][0-9]|3[0-2]))?$`
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made
✅ **Edge Cases:** Comprehensive analysis covers valid/invalid formats, null handling, empty strings, whitespace, set deduplication, and /32 suffix behavior
✅ **Shared Path Merge:** No duplicate parent keys found in merge statements
✅ **Safe References:** All array accesses protected by conditionals (null checks and length checks)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found.

**Verification Details:**
- Field mapping: `ip_range` → `value` (exactly matches Go code: `Value: config["ip_range"].(string)`)
- Validation regex: Identical pattern with proper HCL escaping
- Assignment path: Correctly traced through expandNetworkRuleSet function
- Error message: Matches provider's validation error message format
- Conditional logic: Properly structured with short-circuit evaluation
- Type handling: Direct string assignment (no transformation needed)

**Status:** APPROVED ✅

---
