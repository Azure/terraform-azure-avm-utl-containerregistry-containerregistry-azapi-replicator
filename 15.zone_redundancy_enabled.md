# Task #15 - zone_redundancy_enabled - COMPLETED

## Shadow Implementation

```hcl
# variables.tf
variable "zone_redundancy_enabled" {
  type        = bool
  default     = false                                                                                                     # <-
  nullable    = false                                                                                                     # <-
  description = "(Optional) Whether zone redundancy is enabled for this Container Registry? Changing this forces a new resource to be created. Defaults to `false`."

  validation {                                                                                                            # <-
    condition     = !var.zone_redundancy_enabled || var.sku == "Premium"                                                 # <-
    error_message = "ACR zone redundancy can only be applied when using the Premium Sku"                                 # <-
  }                                                                                                                       # <-
}

# migrate_main.tf
locals {
  replace_triggers_external_values = {
    name = {
      value = var.name
    }
    resource_group_id = {
      value = var.resource_group_id
    }
    location = {
      value = var.location
    }
    zone_redundancy_enabled = {                                                                                           # <-
      value = var.zone_redundancy_enabled                                                                                 # <-
    }                                                                                                                     # <-
  }
  
  body = {
    properties = merge(
      {
        adminUserEnabled         = var.admin_enabled
        anonymousPullEnabled     = var.anonymous_pull_enabled
        dataEndpointEnabled      = var.data_endpoint_enabled
        networkRuleBypassOptions = var.network_rule_bypass_option
        publicNetworkAccess      = var.public_network_access_enabled ? "Enabled" : "Disabled"
        zoneRedundancy           = var.zone_redundancy_enabled ? "Enabled" : "Disabled"                                   # <-
        policies = merge(
          {
            exportPolicy = {
              status = var.export_policy_enabled ? "enabled" : "disabled"
            }
          },
          {
            trustPolicy = {
              status = var.trust_policy_enabled ? "enabled" : "disabled"
            }
          },
          var.quarantine_policy_enabled != null ? {
            quarantinePolicy = {
              status = var.quarantine_policy_enabled ? "enabled" : "disabled"
            }
          } : {},
          var.retention_policy_in_days != null && var.retention_policy_in_days > 0 ? {
            retentionPolicy = {
              status = "enabled"
              days   = var.retention_policy_in_days
            }
          } : {}
        )
      }
    )
    sku = {
      name = var.sku
    }
  }
}
```

## Summary

Root-level boolean argument `zone_redundancy_enabled` with ForceNew behavior, default value false, Premium SKU validation, and enum mapping to Azure API. Implementation exactly replicates provider logic including CustomizeDiff validation and Create phase enum conversion.

## Create Phase Verification

**Query Result:**

From `resourceContainerRegistryCreate` function (lines 405-533):

```go
func resourceContainerRegistryCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ... initialization code ...
	
	zoneRedundancy := registries.ZoneRedundancyDisabled
	if d.Get("zone_redundancy_enabled").(bool) {
		zoneRedundancy = registries.ZoneRedundancyEnabled
	}
	
	// ... build other properties ...
	
	parameters := registries.Registry{
		Location: location.Normalize(d.Get("location").(string)),
		Sku: registries.Sku{
			Name: registries.SkuName(sku),
			Tier: pointer.To(registries.SkuTier(sku)),
		},
		Identity: identity,
		Properties: &registries.RegistryProperties{
			AdminUserEnabled: pointer.To(d.Get("admin_enabled").(bool)),
			Encryption:       expandEncryption(d.Get("encryption").([]interface{})),
			NetworkRuleSet:   networkRuleSet,
			Policies: &registries.Policies{
				QuarantinePolicy: expandQuarantinePolicy(d.Get("quarantine_policy_enabled").(bool)),
				RetentionPolicy:  retentionPolicy,
				TrustPolicy:      trustPolicy,
				ExportPolicy:     expandExportPolicy(d.Get("export_policy_enabled").(bool)),
			},
			PublicNetworkAccess:      &publicNetworkAccess,
			ZoneRedundancy:           &zoneRedundancy,  // <-- Direct assignment in primary create
			AnonymousPullEnabled:     pointer.To(d.Get("anonymous_pull_enabled").(bool)),
			DataEndpointEnabled:      pointer.To(d.Get("data_endpoint_enabled").(bool)),
			NetworkRuleBypassOptions: pointer.To(registries.NetworkRuleBypassOptions(d.Get("network_rule_bypass_option").(string))),
		},
		Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	// ... geo-replication handling ...
	
	d.SetId(id.ID())
	return resourceContainerRegistryRead(d, meta)
}
```

**Pattern Identification:** Single-phase Create operation

**Field Classification:** Create phase - field is set in the primary `CreateThenPoll` operation (line 496), not in any post-creation operation

**Decision:** Implement in `local.body.properties.zoneRedundancy`

## Assignment Path Verification

**Predicted Path:** `body.properties.zoneRedundancy`

**Go Code Evidence:**

From Create function (lines 482-485, 496):
```go
zoneRedundancy := registries.ZoneRedundancyDisabled
if d.Get("zone_redundancy_enabled").(bool) {
	zoneRedundancy = registries.ZoneRedundancyEnabled
}

// ...later in parameters construction...
parameters := registries.Registry{
	// ...
	Properties: &registries.RegistryProperties{
		// ...
		ZoneRedundancy:           &zoneRedundancy,
		// ...
	},
	// ...
}
```

The assignment clearly shows:
1. Variable `zoneRedundancy` is created with enum value
2. Assigned to `parameters.Properties.ZoneRedundancy`
3. `parameters` is of type `registries.Registry`
4. This maps to Azure API path `properties.zoneRedundancy`

**Verified Path:** `body.properties.zoneRedundancy`

**Path Comparison:** Predicted path matches verified path ✅

## Provider Schema

From `internal/services/containers/container_registry_resource.go` (lines 256-261):

```go
"zone_redundancy_enabled": {
	Type:     pluginsdk.TypeBool,
	ForceNew: true,
	Optional: true,
	Default:  false,
},
```

**Key Attributes:**
- Type: `bool`
- Optional: `true`
- ForceNew: `true`
- Default: `false`
- No Sensitive flag
- No Computed flag

## Azure API Schema

**Resource Type:** `Microsoft.ContainerRegistry/registries@2025-04-01`

**Property Path:** `body.properties.zoneRedundancy`

**Type:** `String` (enum)

**Description:** "Whether or not zone redundancy is enabled for this container registry (Possible values: Enabled,Disabled)"

**Provider to API Mapping:**
- Provider: boolean (`true` / `false`)
- Azure API: string enum (`"Enabled"` / `"Disabled"`)

## Hidden Fields

None. The field has a straightforward boolean-to-enum mapping with no additional hidden fields or logic.

## Mapping

**Terraform (Provider) → Azure API:**
- `zone_redundancy_enabled` (snake_case) → `zoneRedundancy` (camelCase)
- `bool` → `String` enum
- `true` → `"Enabled"`
- `false` → `"Disabled"`

## Special Handling

### 1. Default Value

**Provider Implementation (line 260):**
```go
Default:  false,
```

**Replication Strategy:** 
- Added `default = false` in `variables.tf`
- Added `nullable = false` to enforce non-null behavior (root-level argument with default must have `nullable = false`)

### 2. ForceNew Behavior

**Provider Implementation (line 258):**
```go
ForceNew: true,
```

**Replication Strategy:**
- Added to `replace_triggers_external_values` with stable key wrapping:
```hcl
zone_redundancy_enabled = {
  value = var.zone_redundancy_enabled
}
```

This ensures any change to `zone_redundancy_enabled` triggers resource replacement.

### 3. CustomizeDiff Validation

**Provider Implementation (lines 333-336):**
```go
// zone redundancy is only available for Premium Sku.
zoneRedundancyEnabled, ok := d.GetOk("zone_redundancy_enabled")
if ok && zoneRedundancyEnabled.(bool) && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
	return fmt.Errorf("ACR zone redundancy can only be applied when using the Premium Sku")
}
```

**Replication Strategy:**
Implemented in `variables.tf` validation block:
```hcl
validation {
  condition     = !var.zone_redundancy_enabled || var.sku == "Premium"
  error_message = "ACR zone redundancy can only be applied when using the Premium Sku"
}
```

**Logic Breakdown:**
- Provider: `if ok && zoneRedundancyEnabled.(bool) && !strings.EqualFold(sku, string(registries.SkuNamePremium))`
  - Only error when field is set to `true` AND SKU is NOT Premium
- Replication: `!var.zone_redundancy_enabled || var.sku == "Premium"`
  - Condition must be true (no error)
  - If `zone_redundancy_enabled` is `false`, condition is `true` (passes)
  - If `zone_redundancy_enabled` is `true`, condition requires `sku == "Premium"` (passes only if Premium)
  - This exactly matches provider logic

### 4. Enum Conversion

**Provider Implementation (lines 482-485):**
```go
zoneRedundancy := registries.ZoneRedundancyDisabled
if d.Get("zone_redundancy_enabled").(bool) {
	zoneRedundancy = registries.ZoneRedundancyEnabled
}
```

Looking at the Go SDK types, the enum values are:
- `registries.ZoneRedundancyDisabled` = `"Disabled"`
- `registries.ZoneRedundancyEnabled` = `"Enabled"`

**Replication Strategy:**
```hcl
zoneRedundancy = var.zone_redundancy_enabled ? "Enabled" : "Disabled"
```

This ternary expression exactly replicates the if-else logic from the provider.

## Deferred Work Completion

No `following.md` file exists, indicating no work was deferred to this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Provider behavior:** Default is `false` (line 260), field is always non-null
- **Implementation:** Variable has `default = false` and `nullable = false`
- **Match:** ✅ Exact match

### Edge Cases

#### Case 1: zone_redundancy_enabled = true with Basic SKU
- **Provider:** CustomizeDiff returns error (lines 333-336)
- **Implementation:** Validation block prevents this at plan time
- **Result:** ✅ Blocked at plan time (faster than provider)

#### Case 2: zone_redundancy_enabled = true with Standard SKU
- **Provider:** CustomizeDiff returns error
- **Implementation:** Validation block prevents this at plan time
- **Result:** ✅ Blocked at plan time

#### Case 3: zone_redundancy_enabled = true with Premium SKU
- **Provider:** Passes validation, creates with `"Enabled"`
- **Implementation:** Passes validation, creates with `"Enabled"`
- **Result:** ✅ Identical behavior

#### Case 4: zone_redundancy_enabled = false (any SKU)
- **Provider:** Passes validation, creates with `"Disabled"`
- **Implementation:** Passes validation, creates with `"Disabled"`
- **Result:** ✅ Identical behavior

#### Case 5: zone_redundancy_enabled changes from false to true
- **Provider:** ForceNew triggers replacement
- **Implementation:** `replace_triggers_external_values` triggers replacement
- **Result:** ✅ Identical behavior

#### Case 6: zone_redundancy_enabled changes from true to false
- **Provider:** ForceNew triggers replacement
- **Implementation:** `replace_triggers_external_values` triggers replacement
- **Result:** ✅ Identical behavior

### Idempotency
- **First apply:** Creates with specified value
- **Subsequent applies (no change):** No diff, stable
- **Value change:** Forces replacement
- **Result:** ✅ Fully idempotent

### Safe References
All references to `var.zone_redundancy_enabled` and `var.sku` are safe:
- Both are required/non-nullable variables
- No nested object access
- Direct boolean evaluation

### Boundary Conditions
- Boolean type has only two values: `true` and `false`
- Default value `false` ensures non-null behavior
- `nullable = false` prevents null assignments
- All possible boolean values are handled in the ternary expression

## Checklist

- ✅ Property in correct local (`body.properties.zoneRedundancy`)
- ✅ ForceNew wrapped: `{ value = var.zone_redundancy_enabled }`
- ✅ ALL logic EXACTLY replicated from provider (CustomizeDiff validation, enum conversion, ForceNew)
- ✅ Validations IMPLEMENTED in variables.tf (Premium SKU requirement)
- ✅ TODO comment added to original field in variables.tf (N/A - not applicable for root-level arguments)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md (N/A - not deferring any work)
- ✅ Deferred work from following.md (N/A - no following.md exists)
- ✅ Critical review (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis in proof (completed above)
- ✅ Proof created
- ✅ `track.md` update pending
- ✅ Self-Review: Only added zone_redundancy_enabled field, no content from other tasks

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2026-01-26  
**Task:** #15 - zone_redundancy_enabled

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented with stable key wrapping  
✅ **Stable Keys:** Key `zone_redundancy_enabled` always present in `replace_triggers_external_values`  
✅ **Phase Detection:** Field correctly placed in `local.body.properties.zoneRedundancy` (Create phase)  
✅ **Type Conversion:** Correct conversion from `bool` to `String` enum (`"Enabled"` / `"Disabled"`)  
✅ **Null Handling:** Correctly non-nullable with `default = false` and `nullable = false`  
✅ **Validations:** CustomizeDiff Premium SKU validation exactly replicated in `variables.tf`  
✅ **Root-Level Default:** Both `default = false` AND `nullable = false` present (MANDATORY)  
✅ **Deferred Work Completion:** No deferred work for this task (no `following.md` file)  
✅ **Deferred Work Recording:** No deferrals made  
✅ **Edge Cases:** All edge cases properly analyzed and handled (SKU validation, ForceNew triggers, idempotency)  
✅ **Enum Conversion:** Exactly matches provider logic (`true` → `"Enabled"`, `false` → `"Disabled"`)  
✅ **Cross-Variable Validation:** Correctly placed in owning variable with proper logic translation

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The CustomizeDiff validation logic is correctly translated using De Morgan's law, the ForceNew behavior uses stable key wrapping, and the enum conversion precisely matches the provider's if-else logic.

**Status:** APPROVED ✅

---
