# Task #23 - georeplications.tags - PROOF DOCUMENT

## Summary

The `georeplications.tags` field is a simple pass-through assignment that maps tags to the root level of each replication child resource. Tags are already correctly assigned in the `azapi_header` structure created by Task #20 (skeleton). This task verifies the implementation is correct and documents the behavior.

## Create Phase Verification

### Pattern Identification

From Task #20's analysis, georeplications are created as post-creation operations after the primary registry resource.

**Pattern:** Multi-phase create operation
- **Phase 1:** Primary registry creation via `client.CreateThenPoll`
- **Phase 2:** Georeplications creation via `replicationClient.CreateThenPoll`

### SDK Function Identification

From the `expandReplications` function (lines 1112-1134):

```go
func expandReplications(p []interface{}) []replications.Replication {
    reps := make([]replications.Replication, 0)
    if p == nil {
        return reps
    }
    for _, v := range p {
        value := v.(map[string]interface{})
        location := location.Normalize(value["location"].(string))
        tags := tags.Expand(value["tags"].(map[string]interface{}))  // <- Tags expanded here
        zoneRedundancy := replications.ZoneRedundancyDisabled
        if value["zone_redundancy_enabled"].(bool) {
            zoneRedundancy = replications.ZoneRedundancyEnabled
        }
        reps = append(reps, replications.Replication{
            Location: location,
            Name:     &location,
            Tags:     tags,  // <- Direct assignment to Tags (root level)
            Properties: &replications.ReplicationProperties{
                ZoneRedundancy:        &zoneRedundancy,
                RegionEndpointEnabled: pointer.To(value["regional_endpoint_enabled"].(bool)),
            },
        })
    }
    return reps
}
```

**Classification Decision:**
- **Field Classification:** Post-creation operation (Type 5, handled in Task #20's skeleton)
- **SDK Function Type:** `CreateThenPoll` (CreateOrUpdate pattern)
- **Index:** `post_creation0`
- **Resource Type:** `Microsoft.ContainerRegistry/registries/replications@2025-04-01`

The field is processed during the post-creation phase when `applyGeoReplicationLocations` calls `replicationClient.CreateThenPoll` with the `Replication` struct containing the tags.

## Assignment Path Verification

### Predicted Path

For the tags field in georeplications:
```
tags → azapi_header.tags (root level parameter)
```

### Go Code Evidence

From `expandReplications` function (lines 1120-1127):

```go
tags := tags.Expand(value["tags"].(map[string]interface{}))  // <- Expand tags from Terraform state
zoneRedundancy := replications.ZoneRedundancyDisabled
if value["zone_redundancy_enabled"].(bool) {
    zoneRedundancy = replications.ZoneRedundancyEnabled
}
reps = append(reps, replications.Replication{
    Location: location,
    Name:     &location,
    Tags:     tags,  // <- Direct assignment to .Tags field (root level)
```

The `replications.Replication` struct has `Tags` as a root-level field, NOT nested in properties.

### Verified Path

```
replications.Replication struct:
  .Location → azapi_header.location (root level)
  .Name → azapi_header.name (root level)
  .Tags → azapi_header.tags (root level)  ✅
  .Properties.ZoneRedundancy → body.properties.zoneRedundancy
  .Properties.RegionEndpointEnabled → body.properties.regionEndpointEnabled
```

### Path Comparison

**Match:** ✅ The predicted path matches the verified path. Tags are at the root level of the replication resource, assigned to `azapi_header.tags`.

## Provider Schema

From `container_registry_resource.go` (lines 92-123):

```go
"georeplications": {
    // Don't make this a TypeSet since TypeSet has bugs when there is a nested property using `StateFunc`.
    // See: https://github.com/hashicorp/terraform-plugin-sdk/issues/160
    Type:       pluginsdk.TypeList,
    Optional:   true,
    ConfigMode: pluginsdk.SchemaConfigModeAuto,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "location": commonschema.LocationWithoutForceNew(),

            "zone_redundancy_enabled": {
                Type:     pluginsdk.TypeBool,
                Optional: true,
                Default:  false,
            },

            "regional_endpoint_enabled": {
                Type:     pluginsdk.TypeBool,
                Optional: true,
            },

            "tags": commonschema.Tags(),  // <- Tags field definition
        },
    },
},
```

**Schema Properties for `tags`:**
- **Type:** `map[string]string` (from `commonschema.Tags()`)
- **Optional:** Yes
- **Required:** No
- **Default:** None (implicitly `null`)
- **ForceNew:** No

The `commonschema.Tags()` function provides the standard Azure tags schema without validation constraints (tags are free-form key-value pairs in Azure).

## Azure API Schema

### Resource Type

`Microsoft.ContainerRegistry/registries/replications@2025-04-01`

### Schema Query Results

**Type:** `Map(String)`

**Description:** "A mapping of tags which should be assigned to the Azure resource."

### Azure API Structure

```json
{
  "location": "string (Required)",
  "name": "string (Required)",
  "tags": {
    "key1": "value1",
    "key2": "value2"
  },
  "properties": {
    "regionEndpointEnabled": "boolean",
    "zoneRedundancy": "string"
  }
}
```

**Key Points:**
1. `tags` is a root-level field (not inside `properties`)
2. `tags` is optional (can be omitted or null)
3. `tags` is a simple key-value map of strings

## Hidden Fields

**None.** The tags field has no hidden values or transformations. It's a simple pass-through from Terraform state to Azure API.

## Mapping (snake_case → camelCase)

| Terraform (snake_case) | Azure API (camelCase) | Level |
|------------------------|----------------------|-------|
| tags | tags | azapi_header (root) |

**No transformation needed:** The field name "tags" is identical in both Terraform and Azure API.

## Special Handling

### 1. No Validation Required

The `commonschema.Tags()` function provides a generic tags schema without specific validation rules. Azure accepts any key-value pairs as tags (with platform-level constraints like length limits that Azure enforces automatically).

**From variables.tf (line 138):**
```hcl
tags = optional(map(string))
```

No additional validations are needed beyond the type constraint already in `variables.tf`.

### 2. ForceNew Analysis

#### Update Method Behavior

From `applyGeoReplicationLocations` function (lines 895-907):

```go
// Compare old and new replication parameters to see whether it has updated.
otag, ntag := *oldRepl.Tags, *newRepl.Tags
if len(otag) != len(ntag) {
    needUpdate = true  // <- Sets needUpdate, NOT needReplace
} else {
    for k, ov := range otag {
        nv, ok := ntag[k]
        if !ok {
            needUpdate = true
            break
        }
        if ov != nv {
            needUpdate = true
            break
        }
    }
}

if !needUpdate {
    continue
}

if needReplace {
    // ... delete and recreate logic ...
}

id := replications.NewReplicationID(registryId.SubscriptionId, registryId.ResourceGroupName, registryId.RegistryName, loc)
if err := replicationClient.CreateThenPoll(ctx, id, newRepl); err != nil {
    return fmt.Errorf("creating/updating %s: %+v", id, err)
}
```

**ForceNew Decision:** ✅ **NO ForceNew**

**Evidence:**
- Tags changes set `needUpdate = true` but NOT `needReplace = true`
- When `needReplace` is false, the code calls `CreateThenPoll` which performs an in-place update
- Tags can be added, removed, or modified without recreating the replication resource

**Conclusion:** No ForceNew tracking needed in `replace_triggers_external_values`.

### 3. Sensitive Fields

**None.** Tags are not sensitive data.

### 4. Implementation Status

The implementation is **already complete** in Task #20's skeleton. From `migrate_main.tf` (lines 83-106):

```hcl
post_creation0 = var.georeplications != null && length(var.georeplications) > 0 ? [
  for idx, repl in var.georeplications : {
    azapi_header = {
      type                 = "Microsoft.ContainerRegistry/registries/replications@2025-04-01"
      name                 = repl.location
      location             = repl.location
      parent_id            = "${var.resource_group_id}/providers/Microsoft.ContainerRegistry/registries/${var.name}"
      tags                 = repl.tags  # ✅ Already implemented
      ignore_null_property = true
      retry                = null
    }
    body = {
      properties = merge(
        repl.regional_endpoint_enabled != null ? {
          regionEndpointEnabled = repl.regional_endpoint_enabled
        } : {},
        {
          # zoneRedundancy = ... # Task #24
        }
      )
    }
    locks = local.locks
  }
] : null
```

The assignment `tags = repl.tags` correctly:
1. Places tags at root level (`azapi_header.tags`)
2. Passes through the value from `var.georeplications[].tags`
3. Handles null values correctly (Azure accepts null/omitted tags)

## Shadow Implementation

**No changes needed.** The implementation in `migrate_main.tf` is already correct.

```hcl
# ===== migrate_main.tf (ALREADY IMPLEMENTED) =====

locals {
  # ... existing locals ...
  
  post_creation0 = var.georeplications != null && length(var.georeplications) > 0 ? [
    for idx, repl in var.georeplications : {
      azapi_header = {
        type                 = "Microsoft.ContainerRegistry/registries/replications@2025-04-01"
        name                 = repl.location
        location             = repl.location
        parent_id            = "${var.resource_group_id}/providers/Microsoft.ContainerRegistry/registries/${var.name}"
        tags                 = repl.tags  # <- VERIFIED CORRECT
        ignore_null_property = true
        retry                = null
      }
      body = {
        properties = merge(
          repl.regional_endpoint_enabled != null ? {
            regionEndpointEnabled = repl.regional_endpoint_enabled
          } : {},
          {
            # zoneRedundancy = ... # Task #24
          }
        )
      }
      locks = local.locks
    }
  ] : null
}
```

## Deferred Work Completion

Checked `following.md` - file does not exist. No deferred work to complete.

## Critical Review & Edge Cases

### Edge Case Analysis

**1. Null Semantics**
- **`repl.tags = null`**: Azure accepts null tags → resource created without tags ✅
- **`repl.tags = {}`**: Empty map → resource created with no tags (equivalent to null) ✅
- **`repl.tags = {"key": "value"}`**: Normal case → tags applied correctly ✅

**2. Empty Collections**
- **Empty map `{}`**: Valid, treated as no tags by Azure ✅
- Terraform's `optional(map(string))` allows null or map values ✅

**3. Update Scenarios**
- **Add tags:** `null` → `{"key": "value"}` → In-place update (needUpdate=true, needReplace=false) ✅
- **Remove tags:** `{"key": "value"}` → `null` → In-place update ✅
- **Modify tags:** `{"k1": "v1"}` → `{"k1": "v2"}` → In-place update ✅
- **Add/remove keys:** `{"k1": "v1"}` → `{"k1": "v1", "k2": "v2"}` → In-place update ✅

**4. Idempotency**
- Tags are stored as a map, order doesn't matter ✅
- Terraform's map type ensures consistent handling ✅
- Provider compares tags key-by-key, order-independent ✅

**5. Safe References**
- Access `repl.tags` is safe because `repl` comes from `for idx, repl in var.georeplications` ✅
- `optional(map(string))` in schema allows null values without errors ✅
- Azure API accepts null/omitted tags without errors ✅

**6. Special Considerations**

**Azure Tags Constraints (Platform-Level):**
- Maximum 50 tags per resource (Azure enforces)
- Key length: 1-512 characters
- Value length: 0-256 characters
- Case-insensitive key names (Azure normalizes)

These constraints are enforced by Azure API automatically and don't require Terraform-level validation.

**Ignore Null Property:**
The `ignore_null_property = true` setting in `azapi_header` means:
- If `repl.tags = null`, the `tags` field is omitted from the API request
- Azure treats omitted tags as "no tags" (correct behavior)
- No unnecessary null values sent to API ✅

## Implementation Verification

### Current State

**From `migrate_main.tf` (line 90):**
```hcl
tags = repl.tags
```

### Verification Checklist

✅ **Placement:** Root level in `azapi_header` (correct - tags are root-level in Azure API)
✅ **Source:** `repl.tags` from `var.georeplications[].tags` (correct - direct pass-through)
✅ **Null Handling:** `optional(map(string))` allows null, `ignore_null_property = true` omits null (correct)
✅ **Type:** `map(string)` matches Azure API `Map(String)` (correct)
✅ **ForceNew:** Not needed (tags are updatable in-place)
✅ **Validation:** None needed (Azure tags are free-form)

### Comparison with Provider Behavior

**Provider Logic (expandReplications):**
```go
tags := tags.Expand(value["tags"].(map[string]interface{}))
reps = append(reps, replications.Replication{
    Tags: tags,
    // ...
})
```

**Our Implementation:**
```hcl
tags = repl.tags
```

**Match:** ✅ Exactly replicates provider behavior - simple pass-through assignment.

## Checklist

- ✅ Property verified in correct location (azapi_header.tags, root level)
- ✅ No ForceNew needed (tags updatable in-place)
- ✅ Implementation exactly replicates provider behavior (simple pass-through)
- ✅ No validations needed (free-form tags)
- ✅ No hidden fields
- ✅ No deferred work from following.md
- ✅ Critical review completed (null handling, updates, idempotency verified)
- ✅ Edge case analysis completed
- ✅ Proof document created
- ✅ Ready to update track.md

## Self-Review

**Content Verified:**
- ✅ Confirmed assignment is correct in migrate_main.tf (line 90)
- ✅ No additional code changes needed
- ✅ Documentation complete

**No Extra Content:**
- ✅ Did NOT modify other fields
- ✅ Did NOT add unnecessary code
- ✅ Proof document only (no code changes)

**Scope Verification:** ✅ All content is within Task #23 scope (georeplications.tags field only).

---

**IMPLEMENTATION STATUS:** ✅ COMPLETE (no code changes required - already implemented correctly in Task #20 skeleton)

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #23 - georeplications.tags

### Validation Results

✅ **Schema Compliance:** Field correctly placed in `azapi_header.tags` (root level), matching Azure API structure
✅ **Assignment Path:** Verified `repl.tags` → `azapi_header.tags` matches provider's `expandReplications` function exactly
✅ **ForceNew Logic:** Correctly identified as NOT ForceNew (tags changes trigger in-place update via `needUpdate`, not `needReplace`)
✅ **Stable Keys:** Tags key always present in `azapi_header`, no conditional add/remove
✅ **Type Conversion:** Direct pass-through of `map(string)`, correctly matches Azure API `Map(String)`
✅ **Null Handling:** `optional(map(string))` with `ignore_null_property = true` correctly handles null semantics
✅ **Validations:** Correctly determined none required (Azure tags are free-form, no provider validations)
✅ **Deferred Work Completion:** No deferred work exists (`following.md` does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive analysis of null values, empty maps, updates, and idempotency
✅ **Implementation Exact Match:** Simple pass-through assignment exactly replicates provider behavior

### Code Review

**From `migrate_main.tf` (line 90):**
```hcl
tags = repl.tags
```

**Provider Source (expandReplications, lines 1120-1127):**
```go
tags := tags.Expand(value["tags"].(map[string]interface{}))
reps = append(reps, replications.Replication{
    Tags: tags,  // Root-level assignment
    // ...
})
```

**Match Verification:** ✅ Implementation is a direct pass-through that exactly replicates the provider's simple assignment behavior.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:
1. Tags placed at correct level (root, not in properties)
2. Simple pass-through matches provider's simple assignment
3. No ForceNew (correctly identified as updatable in-place)
4. No validations needed (correctly assessed - tags are free-form)
5. All edge cases properly analyzed and handled
6. No deviations, simplifications, or "safer alternatives" present

The implementation was completed correctly in Task #20's skeleton and requires no modifications.

**Status:** APPROVED ✅

---
