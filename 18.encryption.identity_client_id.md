# Task #18 - encryption.identity_client_id

## Summary
Implemented the `identity_client_id` argument within the existing `encryption` block. This field specifies the client ID of the managed identity associated with the encryption key and is Required when encryption is configured.

## Shadow Implementation
```hcl
# In migrate_main.tf
locals {
  body = {
    properties = merge(
      {
        # ... existing fields ...
      },
      var.encryption != null && length(var.encryption) > 0 ? { # <-
        encryption = { # <-
          keyVaultProperties = { # <-
            identity = var.encryption[0].identity_client_id # <-
            # keyIdentifier = ... # Task #19 # <-
          } # <-
          status = "enabled" # Hidden field - always enabled when encryption is configured # <-
        } # <-
      } : {} # <-
    )
  }
}

# In variables.tf
variable "encryption" {
  # ... existing definition ...
  
  validation { # <-
    condition = var.encryption == null || length(var.encryption) == 0 || can(regex("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", var.encryption[0].identity_client_id)) # <-
    error_message = "identity_client_id must be a valid UUID" # <-
  } # <-
}
```

## Create Phase Verification

### Provider Create Method Evidence
From `resourceContainerRegistryCreate` (lines 505):
```go
Properties: &registries.RegistryProperties{
    AdminUserEnabled: pointer.To(d.Get("admin_enabled").(bool)),
    Encryption:       expandEncryption(d.Get("encryption").([]interface{})),
    NetworkRuleSet:   networkRuleSet,
    // ... other properties
}
```

From `expandEncryption` function (lines 1013-1025):
```go
func expandEncryption(input []interface{}) *registries.EncryptionProperty {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})
    return &registries.EncryptionProperty{
        KeyVaultProperties: &registries.KeyVaultProperties{
            Identity:      pointer.To(v["identity_client_id"].(string)),  // <- Line 1019
            KeyIdentifier: pointer.To(v["key_vault_key_id"].(string)),
        },
        Status: pointer.To(registries.EncryptionStatusEnabled),
    }
}
```

**Pattern:** Single-phase - the `identity_client_id` field is set during the primary `CreateThenPoll` operation.

**Field Classification:** Create phase - included in the initial resource creation payload via `expandEncryption()` which is called during Create.

**Decision:** Implement in `local.body.properties.encryption.keyVaultProperties.identity` (not post-creation).

## Assignment Path Verification

### Predicted Path
`properties.encryption.keyVaultProperties.identity`

### Go Code Evidence - Tracing Assignment Path

**Step 1: Field Access**
From `expandEncryption` (line 1019):
```go
Identity: pointer.To(v["identity_client_id"].(string)),
```
The `identity_client_id` value is extracted from the Terraform config.

**Step 2: Struct Assignment**
From `expandEncryption` (lines 1017-1023):
```go
return &registries.EncryptionProperty{
    KeyVaultProperties: &registries.KeyVaultProperties{
        Identity:      pointer.To(v["identity_client_id"].(string)),
        KeyIdentifier: pointer.To(v["key_vault_key_id"].(string)),
    },
    Status: pointer.To(registries.EncryptionStatusEnabled),
}
```
- `Identity` is assigned to the `KeyVaultProperties` struct
- `KeyVaultProperties` is assigned to the `EncryptionProperty` struct

**Step 3: Properties Assignment**
From `resourceContainerRegistryCreate` (line 505):
```go
Properties: &registries.RegistryProperties{
    Encryption: expandEncryption(d.Get("encryption").([]interface{})),
}
```
- The result of `expandEncryption()` is assigned to `Properties.Encryption`

**Step 4: Final Marshal**
The `Properties` struct is marshaled to `properties` in the Azure API request body.

**Assignment Trace:**
1. `v["identity_client_id"]` → extracted from Terraform config
2. `KeyVaultProperties.Identity` → assigned in expandEncryption
3. `EncryptionProperty.KeyVaultProperties` → nested struct
4. `RegistryProperties.Encryption` → assigned to Properties
5. `properties.encryption.keyVaultProperties.identity` → final API path

### Verified Path
`properties.encryption.keyVaultProperties.identity`

### Path Comparison
✅ **MATCH** - Predicted path matches verified path.

## Provider Schema

### Schema Definition (lines 150-153)
```go
"identity_client_id": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: validation.IsUUID,
},
```

**Key Properties:**
- **Type:** TypeString
- **Required:** true (within encryption block)
- **Optional:** false
- **ForceNew:** Not specified (false) - changes can be updated
- **Computed:** false
- **Sensitive:** false
- **ValidateFunc:** `validation.IsUUID` - ensures valid UUID format

**Validation Logic:**
The provider uses `validation.IsUUID` which validates the standard UUID format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx` where x is a hexadecimal digit.

## Azure API Schema

### Query Result
From Azure API schema for `Microsoft.ContainerRegistry/registries@2025-04-01`:
```
body.properties.encryption.keyVaultProperties.identity: String
```

**Structure:**
- Path: `properties.encryption.keyVaultProperties.identity`
- Type: String
- Optional: true (at API level, but Required in provider schema when encryption is set)

## Hidden Fields
No hidden fields for this specific argument. The hidden field `status` at the encryption level was already handled in Task #17.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `identity_client_id` | `keyVaultProperties.identity` | Required String, UUID format |

## Special Handling

### Validation
Added UUID format validation to `variables.tf`:

```hcl
validation {
  condition = var.encryption == null || length(var.encryption) == 0 || can(regex("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", var.encryption[0].identity_client_id))
  error_message = "identity_client_id must be a valid UUID"
}
```

**Source:** Provider schema line 153: `ValidateFunc: validation.IsUUID`

**Rationale:** The provider validates UUID format at plan time. We MUST replicate this validation to provide the same user experience with AzAPI provider. This prevents Azure API errors and provides fast feedback.

**UUID Format:** Standard RFC 4122 format with 8-4-4-4-12 hexadecimal digits separated by hyphens.

### ForceNew Behavior
- **Schema:** No `ForceNew: true` specified
- **CustomizeDiff:** No ForceNew logic for encryption or identity_client_id field
- **Update Method:** The Update method (lines 712-714) explicitly handles encryption changes:
  ```go
  if d.HasChange("encryption") {
      payload.Properties.Encryption = expandEncryption(d.Get("encryption").([]interface{}))
  }
  ```
- **Conclusion:** Changes to `identity_client_id` can be applied via Update operation without resource replacement
- **Implementation:** No entry in `replace_triggers_external_values` needed

### Sensitive Fields
The `identity_client_id` field is NOT sensitive - it's a client ID (UUID) that identifies a managed identity, not a secret or credential. It can be safely stored in state and displayed in plans.

### Block Context
This field is only present when the parent `encryption` block is configured. The implementation correctly checks:
```hcl
var.encryption != null && length(var.encryption) > 0 ? {
  encryption = {
    keyVaultProperties = {
      identity = var.encryption[0].identity_client_id
    }
  }
} : {}
```

This ensures:
- The encryption block is only sent when user provides encryption configuration
- Accessing `var.encryption[0]` is safe because the condition guarantees at least 1 item exists

## Critical Review & Edge Case Analysis

### Null Semantics
- **`var.encryption = null`**: No encryption block sent to API - identity_client_id not relevant
- **`var.encryption = []`**: Same as null - no encryption block sent
- **`var.encryption = [{identity_client_id = "...", ...}]`**: Encryption configured, identity_client_id is sent to API

### Edge Cases

1. **Empty String Handling:**
   UUID validation rejects empty strings:
   ```hcl
   can(regex("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$", ""))
   # Returns false - validation fails
   ```

2. **Invalid UUID Formats:**
   - Missing hyphens: `550e8400e29b41d4a716446655440000` - rejected ✅
   - Wrong group lengths: `550e8400-e29b-41d4-a716-4466554400` - rejected ✅
   - Non-hex characters: `550e8400-e29b-41d4-a716-44665544000g` - rejected ✅
   - Uppercase/lowercase: Both accepted (case-insensitive regex) ✅

3. **Required Field Logic:**
   The field is Required when encryption block is present. Since the encryption block is already validated for Premium SKU (Task #17), and the provider's Required constraint is enforced by Terraform's type system (field must be present in object), no additional cross-field validation is needed.

4. **Safe Array Access:**
   Using `var.encryption[0].identity_client_id` is safe because:
   - Condition checks `length(var.encryption) > 0` before accessing
   - MaxItems validation (Task #17) ensures at most 1 item
   - Result: Always safe to access index [0]

5. **Idempotency:**
   UUID values are immutable identifiers. Repeated applies with the same UUID will not cause any changes or resource recreation. ✅

6. **Update Behavior:**
   Changing the identity_client_id triggers an update (not ForceNew):
   - Old UUID: `550e8400-e29b-41d4-a716-446655440000`
   - New UUID: `6ba7b810-9dad-11d1-80b4-00c04fd430c8`
   - Result: Update operation modifies encryption configuration in-place ✅

### Boundary Conditions
- **Minimum Length:** 36 characters (UUID standard format) - enforced by regex
- **Maximum Length:** 36 characters (UUID standard format) - enforced by regex
- **Character Set:** Only hexadecimal digits [0-9a-fA-F] and hyphens - enforced by regex

## Deferred Work Completion
Checked `following.md` - file does not exist. No work was deferred to this task.

## Checklist

- ✅ Property in correct local (`local.body.properties.encryption.keyVaultProperties.identity`)
- ✅ Comment placeholder replaced with actual implementation
- ✅ Validation implemented in variables.tf (UUID format - MANDATORY)
- ✅ ForceNew checked (not applicable - field supports in-place updates)
- ✅ Sensitive fields checked (not sensitive - just an identifier)
- ✅ Hidden fields checked (none for this field)
- ✅ Create phase verified (single-phase, in primary create via expandEncryption)
- ✅ Assignment path traced and verified (matches prediction)
- ✅ Provider schema analyzed (Required, TypeString, IsUUID validation)
- ✅ Azure API schema queried (String type at keyVaultProperties.identity)
- ✅ Mapping documented (snake_case to camelCase)
- ✅ Block context handled (conditional on encryption block presence)
- ✅ Critical review performed (null semantics, edge cases)
- ✅ Edge case analysis completed (UUID validation, safe access, idempotency)
- ✅ Deferred work checked (none)
- ✅ Proof document created
- ✅ Implementation EXACTLY matches provider behavior
- ✅ Self-review: Only identity_client_id implemented, keyIdentifier left for Task #19

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #18 - encryption.identity_client_id

### Validation Results

✅ **ForceNew Logic:** Not ForceNew - field supports in-place updates via Update method (verified in provider code lines 712-714)
✅ **Stable Keys:** No entry in replace_triggers_external_values - correct (not ForceNew)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase via expandEncryption function)
✅ **Type Conversion:** Correct - TypeString (provider) → String (Azure API), direct mapping
✅ **Null Handling:** Correctly handles conditional presence via parent block check (`var.encryption != null && length(var.encryption) > 0`)
✅ **Validations:** UUID validation implemented in variables.tf line 107-109, exactly replicates provider's `validation.IsUUID`
✅ **Deferred Work Completion:** No following.md exists - no deferred work to complete
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive analysis - UUID format validation, safe array access, idempotency verified
✅ **Assignment Path:** Correctly traced - `properties.encryption.keyVaultProperties.identity` matches prediction
✅ **Comment Placeholder:** Properly replaced Task #18 placeholder, correctly preserved Task #19 placeholder
✅ **Sensitive Fields:** Correctly identified as NOT sensitive (just an identifier)
✅ **Block Context:** Safely checks encryption block presence before accessing [0] index

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The validation logic precisely matches the provider's `validation.IsUUID` function, and the field placement matches the provider's `expandEncryption` function structure.

**Status:** APPROVED ✅

---
