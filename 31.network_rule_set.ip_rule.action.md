# Task #31: network_rule_set.ip_rule.action Argument

## Summary
Implemented the `network_rule_set.ip_rule.action` argument in the existing ip_rule block skeleton. The field is Required in the provider schema, accepts only "Allow" value, and maps directly to the Azure API's `action` field. Validation added to variables.tf to enforce the "Allow" value constraint.

## Shadow Implementation

```hcl
# In migrate_main.tf - local.body.properties.networkRuleSet.ipRules
for rule in var.network_rule_set[0].ip_rule : {  # <-
  action = rule.action  # <-
  # value = ... # Task #32  # <-
}  # <-

# In variables.tf - validation block for network_rule_set
validation {  # <-
  condition = var.network_rule_set == null || length(var.network_rule_set) == 0 || alltrue([  # <-
    for nrs in var.network_rule_set :  # <-
    nrs.ip_rule == null || alltrue([  # <-
      for rule in nrs.ip_rule :  # <-
      rule.action == "Allow"  # <-
    ])  # <-
  ])  # <-
  error_message = "ip_rule.action must be 'Allow' (only supported value at this time)"  # <-
}  # <-
```

## Create Phase Verification

### Provider Create Method Evidence

**Query:** GitHub source code analysis of `resourceContainerRegistryCreate` and `expandNetworkRuleSet` functions.

**Create Method (Lines 449-451):**
```go
networkRuleSet := expandNetworkRuleSet(d.Get("network_rule_set").([]interface{}))
if networkRuleSet != nil && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return fmt.Errorf("`network_rule_set_set` can only be specified for a Premium Sku. If you are reverting from a Premium to Basic SKU please set network_rule_set = []")
}
```

**Primary Create Operation (Lines 493-510):**
```go
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    Identity: identity,
    Properties: &registries.RegistryProperties{
        AdminUserEnabled: pointer.To(d.Get("admin_enabled").(bool)),
        Encryption:       expandEncryption(d.Get("encryption").([]interface{})),
        NetworkRuleSet:   networkRuleSet,  // <- Network rule set (including action) assigned here
        // ...
    },
    Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
}

if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**expandNetworkRuleSet Function (Lines 1046-1065):**
```go
func expandNetworkRuleSet(profiles []interface{}) *registries.NetworkRuleSet {
    if len(profiles) == 0 {
        return nil
    }

    profile := profiles[0].(map[string]interface{})

    ipRuleConfigs := profile["ip_rule"].(*pluginsdk.Set).List()
    ipRules := make([]registries.IPRule, 0)
    for _, ipRuleInterface := range ipRuleConfigs {
        config := ipRuleInterface.(map[string]interface{})
        newIpRule := registries.IPRule{
            Action: pointer.To(registries.Action(config["action"].(string))),  // <- action field extracted here
            Value:  config["ip_range"].(string),
        }
        ipRules = append(ipRules, newIpRule)
    }

    return &registries.NetworkRuleSet{
        DefaultAction: registries.DefaultAction(profile["default_action"].(string)),
        IPRules:       &ipRules,
    }
}
```

**Pattern:** Single-phase creation with one `CreateThenPoll` operation.

**Classification:** `network_rule_set.ip_rule.action` is processed during the **Create phase** (included in primary `CreateThenPoll` operation). The field is extracted from user input in `expandNetworkRuleSet` and included in the request body.

**Decision:** Implement the field in `local.body.properties.networkRuleSet.ipRules[].action` within the existing for-expression created by Task #30.

## Assignment Path Verification

### Predicted Path
`body.properties.networkRuleSet.ipRules[].action`

### Go Code Evidence

**expandNetworkRuleSet Function (Lines 1050-1055):**
```go
config := ipRuleInterface.(map[string]interface{})
newIpRule := registries.IPRule{
    Action: pointer.To(registries.Action(config["action"].(string))),  // <- Field extracted from config
    Value:  config["ip_range"].(string),
}
ipRules = append(ipRules, newIpRule)  // <- Added to ipRules array
```

**Return Statement (Lines 1062-1065):**
```go
return &registries.NetworkRuleSet{
    DefaultAction: registries.DefaultAction(profile["default_action"].(string)),
    IPRules:       &ipRules,  // <- Array assigned to IPRules field
}
```

**Struct Assignment in Create (Line 510):**
```go
NetworkRuleSet:   networkRuleSet,  // <- Assigned to Properties.NetworkRuleSet
```

**Path Trace:**
1. `expandNetworkRuleSet` extracts `action` from config map
2. Creates `registries.IPRule` struct with `Action` field set to `config["action"]`
3. Appends to `ipRules` slice
4. Returns `registries.NetworkRuleSet` with `IPRules` field set to `&ipRules`
5. Assigned to `parameters.Properties.NetworkRuleSet`
6. `parameters` is of type `registries.Registry`

**Azure API Structure:**
- `Registry.Properties.NetworkRuleSet.IPRules[].Action`
- In JSON: `properties.networkRuleSet.ipRules[].action`

### Verified Path
`body.properties.networkRuleSet.ipRules[].action`

### Path Comparison
✅ **Match**: Predicted path matches actual assignment path.

## Provider Schema

**Schema Definition (Lines 180-187):**
```go
"action": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(registries.ActionAllow),
    }, false),
},
```

**Key Properties:**
- **Type:** String
- **Required:** true (field must be provided)
- **ValidateFunc:** `StringInSlice(["Allow"], false)` - only "Allow" is accepted
- **No Default:** No default value specified
- **No ForceNew:** Field can be updated in place
- **No Sensitive:** Not marked as sensitive
- **No Computed:** Not computed by provider

**Validation Logic:**
The provider enforces that the `action` field must be exactly "Allow" (case-sensitive based on `false` parameter to `StringInSlice`). This is the only value supported by Azure Container Registry at this time.

## Azure API Schema

**Query:** Azure API schema for `Microsoft.ContainerRegistry/registries@2025-04-01`

**Path:** `body.properties.networkRuleSet.ipRules`

**Schema Result:**
```
List(ObjectWithOptionalAttrs(map[string]Type{"action":String, "value":String}, []string{"action"}))
```

**Interpretation:**
- Parent: Array of objects (`List`)
- Field: `action` (String type)
- Required: Yes (listed in optional attrs list means "action" is NOT optional, i.e., required)

**Azure API Documentation Query:**
Attempted to query documentation for `body.properties.networkRuleSet.ipRules.action` but failed because `ipRules` is an array, not an object. 

**Query at parent level:** `body.properties.networkRuleSet`
```json
{
  "defaultAction": "The default action of allow or deny when no other rules match. (Required) (Possible values: Allow,Deny)",
  "ipRules": "The IP ACL rules."
}
```

**Azure API Field Properties:**
- Name: `action` (camelCase, same as provider)
- Type: String
- Required: Yes (based on schema analysis)
- Possible Values: "Allow" (based on provider validation)

## Hidden Fields

### Check expandNetworkRuleSet for Hidden Fields

**expandNetworkRuleSet Function (Lines 1050-1055):**
```go
config := ipRuleInterface.(map[string]interface{})
newIpRule := registries.IPRule{
    Action: pointer.To(registries.Action(config["action"].(string))),  // <- From user input
    Value:  config["ip_range"].(string),                                // <- From user input
}
ipRules = append(ipRules, newIpRule)
```

**Analysis:**
- The `IPRule` struct is constructed with only two fields: `Action` and `Value`
- Both fields come directly from user input (`config["action"]` and `config["ip_range"]`)
- No hardcoded values, defaults, or computed fields are added
- No additional fields are set beyond what's in the schema

**Conclusion:** ✅ **No hidden fields detected** for the `action` field. The value is passed through directly from user input to Azure API.

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**
- `action` → `action` (same name, no transformation needed)

**Value Mapping:**
- Provider: `"Allow"` (only supported value)
- Azure API: `"Allow"` (matches provider exactly)

## Special Handling

### Validation - Value Constraint

**Provider Schema Validation (Lines 183-186):**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(registries.ActionAllow),
}, false),
```

**Validation Type:** `StringInSlice` - restricts value to specific set of strings

**Allowed Values:** Only `"Allow"` (the constant `registries.ActionAllow` equals "Allow")

**Case Sensitivity:** `false` parameter means case-sensitive validation

**Implementation in variables.tf:**
```hcl
validation {
  condition = var.network_rule_set == null || length(var.network_rule_set) == 0 || alltrue([
    for nrs in var.network_rule_set :
    nrs.ip_rule == null || alltrue([
      for rule in nrs.ip_rule :
      rule.action == "Allow"
    ])
  ])
  error_message = "ip_rule.action must be 'Allow' (only supported value at this time)"
}
```

**Validation Logic:**
1. Skip validation if `network_rule_set` is null or empty
2. For each network rule set, check if `ip_rule` is null or validate all rules
3. For each ip_rule, ensure `action` equals exactly "Allow"
4. Nested `alltrue` ensures validation passes only when ALL rules have action="Allow"

**Why This Exact Message:**
The error message matches the provider documentation style and clarifies that "Allow" is currently the only supported value (indicating potential future expansion).

### Required Field - No Default

**Provider Behavior:**
- Field marked as `Required: true`
- No `Default` specified
- User MUST provide value explicitly

**Replicator Behavior:**
- Variable definition has no default for `action` field within `ip_rule` object
- Direct assignment: `action = rule.action`
- Validation ensures value is "Allow"
- If user omits field, Terraform will fail at plan time (type constraint enforcement)

**Correctness:** ✅ Matches provider behavior - field must be explicitly provided.

### No ForceNew Logic

**Provider Schema:**
- `ForceNew: true` is NOT present on the `action` field
- Field can be updated in place

**Provider Update Method Check:**
Query Update method to verify no conditional ForceNew logic.

**Update Method (Lines 551-556):**
```go
if d.HasChange("network_rule_set") {
    networkRuleSet := expandNetworkRuleSet(d.Get("network_rule_set").([]interface{}))
    if networkRuleSet != nil && isBasicSku {
        return fmt.Errorf("`network_rule_set_set` can only be specified for a Premium Sku. If you are reverting from a Premium to Basic SKU plese set network_rule_set = []")
    }

    payload.Properties.NetworkRuleSet = networkRuleSet
}
```

**Analysis:**
- Update method checks for changes to entire `network_rule_set` block
- Calls `expandNetworkRuleSet` to rebuild the entire network rule set
- Validates SKU constraint (Premium required)
- No field-level ForceNew logic for `action`
- Azure API accepts updates to `action` field

**Decision:** ✅ **No ForceNew implementation needed** - field can be updated in place. No entry in `replace_triggers_external_values`.

## Deferred Work Completion

**Check following.md:** File does not exist in the project.

**Status:** ✅ No deferred work to complete.

## Critical Review & Edge Case Analysis

### Edge Case 1: Only "Allow" Value Supported

**Scenario:** User attempts to set `action = "Deny"`

**Provider Behavior:**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(registries.ActionAllow),
}, false),
```
- Provider validation rejects any value other than "Allow"
- Error message: validation error from `StringInSlice`

**Replicator Behavior:**
```hcl
validation {
  condition = ... rule.action == "Allow" ...
  error_message = "ip_rule.action must be 'Allow' (only supported value at this time)"
}
```
- Terraform validation fails at plan time
- Clear error message explains only "Allow" is supported

**Correctness:** ✅ Exactly matches provider validation behavior with clearer error message.

### Edge Case 2: Empty String Value

**Scenario:** User provides `action = ""`

**Provider Behavior:**
- `StringInSlice` validation would reject empty string (not in allowed list)

**Replicator Behavior:**
- Type constraint requires string (allows empty string at type level)
- Validation `rule.action == "Allow"` rejects empty string
- Terraform fails at plan time

**Correctness:** ✅ Matches provider behavior - empty string rejected.

### Edge Case 3: Case Sensitivity

**Scenario:** User provides `action = "allow"` (lowercase)

**Provider Behavior:**
- `StringInSlice` with `false` parameter means case-sensitive
- `"allow"` != `"Allow"` → validation fails

**Replicator Behavior:**
- Validation checks `rule.action == "Allow"` (exact match, case-sensitive)
- `"allow"` != `"Allow"` → validation fails

**Correctness:** ✅ Case-sensitive validation matches provider behavior.

### Edge Case 4: Null Value (Impossible)

**Scenario:** User attempts to set `action = null`

**Provider Behavior:**
- Field marked as `Required: true`
- Terraform type system prevents null for required fields in sets

**Replicator Behavior:**
- Type definition: `action = string` (not optional, required in object)
- Terraform enforces non-null at type level
- User cannot provide null value

**Correctness:** ✅ Type system prevents null, matching provider requirement.

### Edge Case 5: Multiple Rules with Different Actions

**Scenario:** User provides multiple ip_rule entries with different `action` values

**Provider Behavior:**
- Each rule independently validated via `StringInSlice`
- All rules must have `action = "Allow"`
- Mixed values → validation fails

**Replicator Behavior:**
```hcl
alltrue([
  for rule in nrs.ip_rule :
  rule.action == "Allow"
])
```
- Validates ALL rules in the set
- `alltrue` ensures every single rule has `action = "Allow"`
- Any rule with different value → validation fails

**Correctness:** ✅ Validates all rules identically to provider.

### Edge Case 6: Future Value Expansion

**Scenario:** Azure adds support for "Deny" action in future API version

**Provider Behavior:**
- Provider schema would update to include "Deny" in `StringInSlice`
- Old code: `[]string{string(registries.ActionAllow)}`
- New code: `[]string{string(registries.ActionAllow), string(registries.ActionDeny)}`

**Replicator Behavior:**
- Current validation: `rule.action == "Allow"`
- To support "Deny", validation would need update to: `contains(["Allow", "Deny"], rule.action)`
- Error message clarifies "only supported value at this time" (hints at future expansion)

**Migration Note:** If Azure API expands supported values, this module will need validation update. Error message communicates this possibility to users.

### Safe References

**Analysis of `rule.action` access:**
- ✅ **Safe:** Accessed within for-expression: `for rule in var.network_rule_set[0].ip_rule`
- ✅ **Safe:** For-expression only executes when condition is true: `var.network_rule_set[0].ip_rule != null && length(...) > 0`
- ✅ **Safe:** `rule.action` is Required field in object type, cannot be null
- ✅ **Safe:** Type system guarantees `rule.action` exists and is string

**No null checks needed:** Required field in object type + safe iteration context.

### Idempotency

**Test:** Apply twice with same `action` value

**Expected:** No changes detected on second apply

**Analysis:**
- First apply: `action = "Allow"` sent to Azure API
- Azure stores: `action: "Allow"`
- Second apply: Read state, compare `"Allow"` == `"Allow"` → no change
- No update triggered

**Correctness:** ✅ Idempotent - applying same value multiple times produces same result.

### Value Transformation

**Provider Code (Line 1053):**
```go
Action: pointer.To(registries.Action(config["action"].(string))),
```

**Transformation Steps:**
1. Extract string from config: `config["action"].(string)`
2. Cast to enum type: `registries.Action(...)`
3. Convert to pointer: `pointer.To(...)`

**Replicator Implementation:**
```hcl
action = rule.action
```

**Transformation Steps:**
1. Extract string from rule object: `rule.action`
2. Assign directly to output

**Why No Pointer Conversion:**
- AzAPI provider 2.0+ accepts native Terraform objects
- No need for `jsonencode()` or manual type conversions
- String value passes through directly

**Correctness:** ✅ Direct assignment sufficient for AzAPI 2.0+ provider.

## Checklist

- ✅ Property in correct local (`body.properties.networkRuleSet.ipRules[].action`)
- ✅ Field placed within existing skeleton created by Task #30
- ✅ Comment placeholder replaced with actual implementation
- ✅ Validation IMPLEMENTED in variables.tf (MANDATORY - enforces "Allow" value)
- ✅ No ForceNew needed (field updates in place)
- ✅ No sensitive handling needed (not marked Sensitive)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (following.md does not exist)
- ✅ Critical review completed (null, edge cases, idempotent, safe refs)
- ✅ Edge Case Analysis in proof (7 scenarios covered)
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Only implemented `action` field for Task #31; did not implement `ip_range` (Task #32); no content from other tasks added

## Implementation Correctness Statement

This implementation EXACTLY replicates the provider behavior:
- ✅ Direct pass-through of `action` field from input to API
- ✅ Validation enforces "Allow" as only supported value (matching provider's `StringInSlice`)
- ✅ Case-sensitive validation (matching provider's `false` parameter)
- ✅ Required field with no default (matching provider schema)
- ✅ No ForceNew logic (field updates in place)
- ✅ No type transformations beyond provider's enum cast (handled by AzAPI provider)

**No deviations, simplifications, or "more conservative" approaches used.** Implementation follows EXACT provider logic as documented in Go source code.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #31 - network_rule_set.ip_rule.action

### Validation Results

✅ **ForceNew Logic:** No ForceNew required - field updates in place (verified in Update method)
✅ **Stable Keys:** Field is within for-expression, key stability requirement not applicable
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Direct assignment, no conversion needed (String → String)
✅ **Null Handling:** Type system prevents null (Required field in object)
✅ **Validations:** Provider validation exactly replicated in variables.tf (lines 255-264) - enforces "Allow" value with `alltrue` across all rules
✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All 7 edge cases properly analyzed (different values, empty string, case sensitivity, null prevention, multiple rules, future expansion, safe references)
✅ **Implementation Placement:** Field correctly added within existing for-expression skeleton created by Task #30
✅ **Comment Placeholder:** Placeholder comment `# action = ... # Task #31` correctly replaced with actual implementation

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. 

**Specific Compliance Points:**
- ✅ Direct pass-through of value matches provider's `config["action"].(string)` extraction
- ✅ Validation in variables.tf (NOT deferred to Azure API) - lines 255-264
- ✅ Validation logic uses `alltrue` to validate ALL rules in ALL network rule sets
- ✅ Case-sensitive validation matches provider's `StringInSlice(..., false)` parameter
- ✅ Error message clear and informative
- ✅ No DiffSuppressFunc, no CustomizeDiff, no complex logic
- ✅ Field is Required without default - type system enforces this
- ✅ AzAPI 2.0+ compliant (no jsonencode/jsondecode)

No deviations, simplifications, or "safer alternatives" were found. The implementation follows the EXACT method prescribed in executor.md for a simple Required field with validation.

**Status:** APPROVED ✅

---
