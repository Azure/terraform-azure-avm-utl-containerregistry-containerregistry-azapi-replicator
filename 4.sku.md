# Task #4: sku - Proof Document

## Summary

The `sku` argument is a required root-level field that specifies the SKU tier for the Container Registry. It is assigned to the `sku.name` property in the Azure API during the Create phase. The field does NOT have ForceNew in the schema but Update logic handles SKU changes with special ordering (Premium upgrade first, Basic/Standard downgrade last). Implementation adds the field to `local.body.sku` with validation for allowed values.

## Shadow Implementation

```hcl
# variables.tf (modified)
variable "sku" {
  type        = string
  description = "(Required) The SKU name of the container registry. Possible values are `Basic`, `Standard` and `Premium`."
  nullable    = false

  validation {  # <-
    condition     = contains(["Basic", "Standard", "Premium"], var.sku)  # <-
    error_message = "'sku' must be one of: Basic, Standard, Premium"  # <-
  }  # <-
}

# migrate_main.tf (modified)
locals {
  body = {
    properties = {}
    sku = {  # <-
      name = var.sku  # <-
    }  # <-
  }
}
```

## Create Phase Verification

**Query Method:** Analyzed the `resourceContainerRegistryCreate` function from the provider source code.

**Pattern:** Single-phase create

**Go Code Evidence:**
```go
// Line 447 - SKU retrieval
sku := d.Get("sku").(string)

// Lines 499-502 - SKU assignment in Create
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    // ... other properties
}

// Line 517 - Primary create operation
if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**Classification:** The `sku` field is assigned to the `parameters.Sku` struct before the primary `CreateThenPoll` operation. This is part of the initial Create phase.

**Decision:** Implement in `local.body` (not a post-creation operation).

## Assignment Path Verification

**Predicted Path:** `sku.name` at the root level of the registry resource body.

**Go Code Evidence:**

1. **Schema Definition (Lines 77-84):**
```go
"sku": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(registries.SkuNameBasic),
        string(registries.SkuNameStandard),
        string(registries.SkuNamePremium),
    }, false),
},
```

2. **Create Assignment (Lines 499-502):**
```go
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    // ...
}
```

The `Sku` field is assigned directly to the `Registry` struct at the root level (not nested under Properties).

3. **Struct Assignment Analysis:**
   - `parameters` is of type `registries.Registry`
   - `.Sku` is assigned directly to the struct (root level)
   - No intermediate pointer or property assignments
   - The SDK struct field `Sku` maps to Azure API's `sku` field

**Verified Path:** `sku.name` (root-level property in body)

**Path Comparison:** ✅ Match - The predicted path matches the actual implementation.

## Provider Schema

**Source:** `internal/services/containers/container_registry_resource.go`

**Schema Definition (Lines 77-84):**
```go
"sku": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(registries.SkuNameBasic),
        string(registries.SkuNameStandard),
        string(registries.SkuNamePremium),
    }, false),
},
```

**Key Characteristics:**
- **Type:** String
- **Required:** true
- **ForceNew:** false (NOT set in schema)
- **Optional:** false
- **Computed:** false
- **Default:** None
- **Validation:** StringInSlice for Basic/Standard/Premium

## Azure API Schema

**Resource Type:** `Microsoft.ContainerRegistry/registries@2025-04-01`

**Property Path:** `body.sku.name`

**Schema Type:** `Object(map[string]Type{"name":String})`

**API Documentation:**
```json
{
  "name": "The SKU name of the container registry. Required for registry creation. (Required) (Possible values: Classic,Basic,Standard,Premium)",
  "tier": "The SKU tier based on the SKU name. (ReadOnly) (Possible values: Classic,Basic,Standard,Premium)"
}
```

**Key Points:**
- `sku.name` is Required at the API level
- Possible values include Classic, Basic, Standard, Premium
- `sku.tier` is ReadOnly and computed by Azure (not user-provided)
- Provider only sends `name`, Azure computes and returns `tier`

## Hidden Fields

**Analysis:** No hidden fields detected for the `sku` property.

**Evidence:** 
- The Create method only sets `Name` and `Tier` in the Sku struct
- `Tier` is computed from `Name` using `registries.SkuTier(sku)` which appears to be a simple type conversion
- No additional hardcoded values or hidden logic found

## Mapping

**Terraform (snake_case):** `sku`

**Azure API (camelCase):** `sku.name`

**Mapping Details:**
- Provider variable: `var.sku` (string value like "Basic", "Standard", "Premium")
- Azure API structure: `{ sku: { name: "Basic" } }`
- The Terraform string is wrapped in an object with a `name` property

## Special Handling

### 1. Validation (MANDATORY - Category 1)

**Provider Validation:**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(registries.SkuNameBasic),
    string(registries.SkuNameStandard),
    string(registries.SkuNamePremium),
}, false),
```

**Implementation:** Added validation block to `variables.tf`:
```hcl
validation {
  condition     = contains(["Basic", "Standard", "Premium"], var.sku)
  error_message = "'sku' must be one of: Basic, Standard, Premium"
}
```

**Rationale:** This is a Category 1 validation (value constraint using StringInSlice). The provider validates that sku must be one of three specific values. This MUST be replicated in variables.tf to provide fast feedback to users.

**Note:** The Azure API documentation mentions "Classic" as a possible value, but the provider schema explicitly excludes it, only allowing Basic/Standard/Premium. We replicate the provider's validation exactly.

### 2. ForceNew Behavior

**Schema Analysis:** The `sku` field does NOT have `ForceNew: true` in the schema definition.

**Update Method Analysis (Lines 551-589):**

The Update method has special logic for SKU changes:

```go
sku := d.Get("sku").(string)
skuChange := d.HasChange("sku")
isBasicSku := strings.EqualFold(sku, string(registries.SkuNameBasic))
isPremiumSku := strings.EqualFold(sku, string(registries.SkuNamePremium))
isStandardSku := strings.EqualFold(sku, string(registries.SkuNameStandard))

// ... other update logic ...

// handle upgrade to Premium SKU first (Line 566)
if skuChange && isPremiumSku {
    if err := applyContainerRegistrySku(d, meta, sku, *id); err != nil {
        return fmt.Errorf("applying sku %q for %s: %+v", sku, id, err)
    }
}

// ... update other properties ...

// downgrade to Basic or Standard SKU (Line 644)
if skuChange && (isBasicSku || isStandardSku) {
    if err := applyContainerRegistrySku(d, meta, sku, *id); err != nil {
        return fmt.Errorf("applying sku %q for %s: %+v", sku, id, err)
    }
}
```

**Key Observations:**
1. SKU changes are handled in-place (no ForceNew)
2. Premium upgrades happen FIRST (before other property updates)
3. Basic/Standard downgrades happen LAST (after other property updates)
4. The `applyContainerRegistrySku` function calls `UpdateThenPoll` with just the SKU change

**Implementation Decision:** 
- ✅ SKU can be updated in place
- ❌ Do NOT add to `replace_triggers_external_values`
- ✅ The ordering logic (upgrade first, downgrade last) is internal to Azure API behavior and does not need replication in our module

**Rationale:** The AzAPI provider will handle the update by sending the new SKU value to the Azure API, which manages the upgrade/downgrade process. The ordering in the provider's Update method is an optimization to handle dependencies between SKU tier and other properties, but the API itself enforces these constraints.

### 3. CustomizeDiff Validations

**Analysis:** The CustomizeDiff function contains multiple SKU-dependent validations:

```go
// Line 307: Geo-replications require Premium
if len(geoReplications) > 0 && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR geo-replication can only be applied when using the Premium Sku")
}

// Line 322: Quarantine policy requires Premium
if quarantinePolicyEnabled && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR quarantine policy can only be applied when using the Premium Sku...")
}

// Line 327: Retention policy requires Premium
if ok && retentionPolicyEnabled.(int) > 0 && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR retention policy can only be applied when using the Premium Sku...")
}

// Line 332: Trust policy requires Premium
if ok && trustPolicyEnabled.(bool) && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR trust policy can only be applied when using the Premium Sku...")
}

// Line 337: Export policy disable requires Premium
if !exportPolicyEnabled {
    if !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
        return errors.New("an ACR export policy can only be disabled when using the Premium Sku...")
    }
}

// Line 347: Encryption requires Premium
if ok && len(encryptionEnabled.([]interface{})) > 0 && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR encryption can only be applied when using the Premium Sku")
}

// Line 352: Zone redundancy requires Premium
if ok && zoneRedundancyEnabled.(bool) && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return fmt.Errorf("ACR zone redundancy can only be applied when using the Premium Sku")
}

// Line 357: Geo-replication zone redundancy requires Premium
for _, loc := range geoReplications {
    loc := loc.(map[string]interface{})
    zoneRedundancyEnabled, ok := loc["zone_redundancy_enabled"]
    if ok && zoneRedundancyEnabled.(bool) && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
        return fmt.Errorf("ACR zone redundancy can only be applied when using the Premium Sku")
    }
}

// Line 365: Anonymous pull requires Standard or Premium
if d.Get("anonymous_pull_enabled").(bool) && (!strings.EqualFold(sku, string(registries.SkuNameStandard)) && !strings.EqualFold(sku, string(registries.SkuNamePremium))) {
    return fmt.Errorf("`anonymous_pull_enabled` can only be applied when using the Standard/Premium Sku")
}

// Line 370: Data endpoint requires Premium
if d.Get("data_endpoint_enabled").(bool) && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return fmt.Errorf("`data_endpoint_enabled` can only be applied when using the Premium Sku")
}
```

**Implementation Decision:** These validations involve cross-field dependencies where OTHER fields depend on the SKU value. According to the ownership rule in executor.md, these validations belong to the tasks that own those respective fields (e.g., Task #20 for georeplications, Task #10 for quarantine_policy_enabled, etc.).

**Deferral:** These SKU-dependent validations will be implemented by the tasks that own the dependent fields. Each of those tasks will add validation blocks to their respective variables that check the SKU requirement.

**Current Task Scope:** This task (#4) only needs to:
1. ✅ Validate that `sku` is one of Basic/Standard/Premium
2. ✅ Add the field to `local.body.sku.name`
3. ✅ NOT add to `replace_triggers_external_values` (in-place update supported)

### 4. Network Rule Set Validation in Create/Update

**Create Method (Line 449-451):**
```go
networkRuleSet := expandNetworkRuleSet(d.Get("network_rule_set").([]interface{}))
if networkRuleSet != nil && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return fmt.Errorf("`network_rule_set_set` can only be specified for a Premium Sku...")
}
```

**Update Method (Line 594-599):**
```go
if d.HasChange("network_rule_set") {
    networkRuleSet := expandNetworkRuleSet(d.Get("network_rule_set").([]interface{}))
    if networkRuleSet != nil && isBasicSku {
        return fmt.Errorf("`network_rule_set_set` can only be specified for a Premium Sku...")
    }
    payload.Properties.NetworkRuleSet = networkRuleSet
}
```

**Implementation Decision:** This validation involves the `network_rule_set` field and belongs to the task that owns that field (Task #28 based on track.md). The current task (#4 - sku) does not need to implement this validation.

**Deferral:** Task #28 (network_rule_set) will implement this SKU-dependent validation.

### 5. Public Network Access Validation in Create/Update

**Create Method (Lines 465-473):**
```go
publicNetworkAccess := registries.PublicNetworkAccessEnabled
if !d.Get("public_network_access_enabled").(bool) {
    if !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
        return errors.New("`public_network_access_enabled` can only be disabled for a Premium Sku")
    }
    publicNetworkAccess = registries.PublicNetworkAccessDisabled
}
```

**Update Method (Lines 601-610):**
```go
if d.HasChange("public_network_access_enabled") {
    publicNetworkAccess := registries.PublicNetworkAccessEnabled
    if !d.Get("public_network_access_enabled").(bool) {
        if !isPremiumSku {
            return errors.New("`public_network_access_enabled` can only be disabled for a Premium Sku")
        }
        publicNetworkAccess = registries.PublicNetworkAccessDisabled
    }
    payload.Properties.PublicNetworkAccess = pointer.To(publicNetworkAccess)
}
```

**Implementation Decision:** This validation involves the `public_network_access_enabled` field and belongs to Task #10 which owns that field.

**Deferral:** Task #10 will implement this SKU-dependent validation.

## Deferred Work Completion

**Check:** Reviewed `following.md` - file does not exist yet.

**Conclusion:** No deferred work from previous tasks applies to this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Field Nature:** Required field with `nullable = false`
- **Null Handling:** Cannot be null - Terraform will enforce this at plan time
- **Default Value:** No default (user must provide)

### Boundary Conditions
- **Valid Values:** Only "Basic", "Standard", "Premium" are allowed
- **Case Sensitivity:** The validation uses exact case matching, consistent with Azure API expectations
- **Empty String:** Prevented by the required nature and validation

### Idempotency
- **Value Stability:** Direct string value assignment ensures idempotent behavior
- **No Transformation:** The value is passed as-is to the API (no case conversion or normalization needed)

### Safe References
- **Direct Access:** `var.sku` is safe because it's a required, non-nullable field
- **No Nested Access:** The value is a simple string, no complex object traversal

### Edge Cases

1. **Case Sensitivity:**
   - Provider validation uses case-sensitive comparison in our validation block
   - Azure API accepts case-insensitive values but provider consistently uses specific casing
   - Implementation uses exact case matching: "Basic", "Standard", "Premium"

2. **Update Behavior:**
   - SKU can be updated in place (no recreation required)
   - Azure API handles upgrade/downgrade logic
   - Some SKU changes may require other fields to be unset (handled by Azure API validation)

3. **Tier Auto-Computation:**
   - Provider sets both `Name` and `Tier` during create: `Tier: pointer.To(registries.SkuTier(sku))`
   - Azure API treats `tier` as ReadOnly
   - Our implementation only sends `name` - Azure will compute and return `tier`
   - This is correct behavior for AzAPI

## Checklist

- ✅ Property in correct local (`local.body.sku.name`)
- ✅ Schema ForceNew analyzed (NOT ForceNew - supports in-place update)
- ✅ CustomizeDiff analyzed (multiple SKU-dependent validations deferred to owning tasks)
- ✅ Update method analyzed (special ordering for SKU changes, but handled by Azure API)
- ✅ Create method analyzed (SKU sent in primary CreateThenPoll)
- ✅ Validation IMPLEMENTED in variables.tf (StringInSlice for Basic/Standard/Premium)
- ✅ All logic EXACTLY replicated from provider (value validation only)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (`following.md` doesn't exist yet - no prior deferred work)
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section added
- ✅ Proof document created
- ✅ Track.md ready to update
- ✅ Self-Review: Only implementing sku field (Task #4), not implementing SKU-dependent validations that belong to other tasks

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #4 - sku

### Validation Results

✅ **ForceNew Logic:** Schema has `ForceNew: false` - correctly NOT added to replace_triggers_external_values. Update method supports in-place SKU changes with special ordering (Premium upgrade first, Basic/Standard downgrade last), which is handled by Azure API.

✅ **Stable Keys:** N/A - Field is not ForceNew

✅ **Phase Detection:** Field correctly placed in `local.body.sku.name` during Create phase. Assignment happens in primary CreateThenPoll operation (lines 499-502 of provider source).

✅ **Type Conversion:** Correct conversion from Terraform string to Azure API object structure `{ sku: { name: "Basic" } }`

✅ **Null Handling:** Required field with `nullable = false` - cannot be null, enforced at plan time

✅ **Validations:** Provider validation `StringInSlice(["Basic", "Standard", "Premium"])` correctly replicated in variables.tf validation block. Cross-field SKU-dependent validations correctly deferred to owning tasks (e.g., georeplications validation to Task #20, network_rule_set validation to Task #28).

✅ **Deferred Work Completion:** No deferred work for this task - `following.md` does not exist yet

✅ **Deferred Work Recording:** Correctly identified and deferred SKU-dependent validations to appropriate owning tasks (documented in proof document with clear rationale)

✅ **Edge Cases:** All edge cases properly analyzed:
- Case sensitivity: Uses exact case matching ("Basic", "Standard", "Premium")
- Update behavior: In-place update supported, no recreation needed
- Tier auto-computation: Only sends `name`, Azure API computes `tier` (ReadOnly)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field validation matches the provider's StringInSlice constraint. The assignment path correctly places the field in `local.body.sku.name` matching the Azure API structure. ForceNew analysis correctly identified that the field supports in-place updates. Cross-field SKU-dependent validations are appropriately deferred to the tasks that own those dependent fields, following the ownership rule in executor.md. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
