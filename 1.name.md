# Task #1 - name - Implementation Proof

## Summary
Implemented the `name` root-level argument for the container registry resource. This is the first executor task that creates the initial Shadow Module structure with `azapi_header`, validations, and ForceNew handling.

## Shadow Implementation

**migrate_main.tf:**
```hcl
locals {
  azapi_header = {
    type                  = "Microsoft.ContainerRegistry/registries@2025-04-01"  # <-
    name                  = var.name  # <-
    location              = var.location  # <-
    parent_id             = var.resource_group_id  # <-
    tags                  = var.tags  # <-
    ignore_null_property  = true  # <-
    retry                 = null  # <-
  }

  replace_triggers_external_values = {
    name = {  # <-
      value = var.name  # <-
    }  # <-
  }
  
  body = {
    properties = {}
  }
  
  sensitive_body = {
    properties = {}
  }
  
  sensitive_body_version = {}
  
  locks = []
}
```

**variables.tf (updated):**
```hcl
variable "name" {
  type        = string
  description = "(Required) Specifies the name of the Container Registry. Only Alphanumeric characters allowed. Changing this forces a new resource to be created."
  nullable    = false

  validation {  # <-
    condition     = can(regex("^[a-zA-Z0-9]+$", var.name))  # <-
    error_message = "alpha numeric characters only are allowed in 'name': ${var.name}"  # <-
  }  # <-

  validation {  # <-
    condition     = length(var.name) >= 5  # <-
    error_message = "'name' cannot be less than 5 characters: ${var.name}"  # <-
  }  # <-

  validation {  # <-
    condition     = length(var.name) <= 50  # <-
    error_message = "'name' cannot be longer than 50 characters: ${var.name} (${length(var.name)})"  # <-
  }  # <-
}
```

**migrate_variables.tf:**
```hcl
variable "resource_group_id" {  # <-
  type        = string  # <-
  description = "(Required) The resource ID of the resource group in which to create the Container Registry. Changing this forces a new resource to be created."  # <-
  nullable    = false  # <-

  validation {  # <-
    condition     = can(regex("^/subscriptions/[a-f0-9-]+/resourceGroups/.+$", var.resource_group_id))  # <-
    error_message = "'resource_group_id' must be a valid resource group ID in the format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}"  # <-
  }  # <-
}  # <-
```

## Create Phase Verification

**Query Result:** The Create method shows a single-phase creation pattern:

```go
func resourceContainerRegistryCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Containers.ContainerRegistryClient.Registries
	operationClient := meta.(*clients.Client).Containers.ContainerRegistryClient.Operation
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()
	log.Printf("[INFO] preparing arguments for  Container Registry creation.")

	id := registries.NewRegistryID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
	
	// ... name availability check ...
	
	parameters := registries.Registry{
		Location: location.Normalize(d.Get("location").(string)),
		// ... other fields ...
		Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}

	// Note: georeplications are handled AFTER primary create as post-creation operations
	newGeoReplicationLocations = expandReplications(d.Get("georeplications").([]interface{}))
	if len(newGeoReplicationLocations) > 0 {
		err = applyGeoReplicationLocations(ctx, meta, id, oldGeoReplicationLocations, newGeoReplicationLocations)
		// ...
	}

	d.SetId(id.ID())
	return resourceContainerRegistryRead(d, meta)
}
```

**Pattern:** Single-phase with post-creation operations for georeplications (handled by separate tasks).

**Field Classification:** The `name` field is used during the primary `CreateThenPoll` operation to construct the resource ID. It's part of the primary Create phase, not a post-operation.

**Decision:** Implement `name` in `local.azapi_header` as a root-level parameter (not in `body` or post-operations).

## Assignment Path Verification

**Predicted Path:** `name` → root-level azapi_resource parameter

**Go Code Evidence:**
```go
// Line 404: resource ID construction
id := registries.NewRegistryID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))

// The name is NOT assigned to parameters.Properties or parameters.Name
// It's used only for resource ID construction
```

**Azure API Context:**
The Azure Resource Manager API expects the resource name as part of the PUT request URL path, not in the request body. This matches the azapi_resource design where `name` is a top-level parameter.

**Verified Path:** `name` → `azapi_resource.name` (root-level)

**Path Comparison:** ✅ MATCH - The predicted path matches the actual implementation.

## Provider Schema

From `internal/services/containers/container_registry_resource.go` (lines 66-71):

```go
"name": {
	Type:         pluginsdk.TypeString,
	Required:     true,
	ForceNew:     true,
	ValidateFunc: containerValidate.ContainerRegistryName,
},
```

**Key Properties:**
- **Type:** String
- **Required:** true
- **ForceNew:** true
- **Validation:** `containerValidate.ContainerRegistryName`

## Azure API Schema

**Query Result:**
```
"Specifies the name of the azure resource. Changing this forces a new resource to be created."
```

**API Type:** String (root-level parameter in azapi_resource, not in body)

## Hidden Fields

No hidden fields detected for the `name` argument. The resource ID is constructed from subscription ID, resource group name, and registry name. No additional hardcoded values are used.

## Mapping

- **Terraform (AzureRM):** `name` (snake_case)
- **Azure API (AzAPI):** `name` (already camelCase, no conversion needed)
- **Variable:** `var.name`

## Special Handling

### 1. ForceNew Implementation

The `name` field has `ForceNew: true` in the provider schema. This means any change to the name requires resource replacement.

**Implementation:**
```hcl
replace_triggers_external_values = {
  name = {
    value = var.name
  }
}
```

**Rationale:** Following executor.md Mode 1 - Direct Value Tracking. The key `name` is always present with a nested `value` field that tracks the actual name value. Any change to `var.name` will trigger a resource replacement.

### 2. Validation Implementation

The provider uses a custom validation function `ContainerRegistryName` (from `internal/services/containers/validate/container_registry_name.go`):

```go
func ContainerRegistryName(v interface{}, k string) (warnings []string, errors []error) {
	value := v.(string)
	if !regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(value) {
		errors = append(errors, fmt.Errorf(
			"alpha numeric characters only are allowed in %q: %q", k, value))
	}

	if 5 > len(value) {
		errors = append(errors, fmt.Errorf("%q cannot be less than 5 characters: %q", k, value))
	}

	if len(value) > 50 {
		errors = append(errors, fmt.Errorf("%q cannot be longer than 50 characters: %q %d", k, value, len(value)))
	}

	return warnings, errors
}
```

**Replicated in variables.tf:**
- Alphanumeric characters only: `^[a-zA-Z0-9]+$`
- Minimum length: 5 characters
- Maximum length: 50 characters

All three validations are implemented as separate validation blocks in `variables.tf` to provide clear error messages.

### 3. No Sensitive Handling

The `name` field is not marked as Sensitive or WriteOnly, so it goes directly in `azapi_header`, not in `sensitive_body`.

### 4. Parent ID Conversion

Since AzAPI uses `parent_id` instead of `resource_group_name`, a new variable `resource_group_id` is created in `migrate_variables.tf`. This allows users to provide the resource group as an ID, which is the format expected by azapi_resource.

## Deferred Work Completion

Checked `following.md` - file does not exist yet. No deferred work to complete.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Meaning:** The `name` field is Required, so null is not allowed.
- **Implementation:** `nullable = false` in variable definition.
- **Validation:** Terraform will enforce non-null at plan time.

### Edge Cases

1. **Empty String:**
   - **Behavior:** Validation will catch this (minimum length 5 characters).
   - **Safe:** ✅ Validation prevents empty strings.

2. **Special Characters:**
   - **Behavior:** Validation enforces alphanumeric only.
   - **Safe:** ✅ Regex validation prevents special characters.

3. **Length Boundaries:**
   - **Minimum (5):** Tested by validation `length(var.name) >= 5`
   - **Maximum (50):** Tested by validation `length(var.name) <= 50`
   - **Safe:** ✅ Both boundaries are explicitly checked.

4. **Case Sensitivity:**
   - **Behavior:** Azure Container Registry names are case-insensitive but stored as lowercase.
   - **Implementation:** We pass the value as-is. Azure API will handle normalization.
   - **Safe:** ✅ No explicit case conversion needed (Azure handles it).

### Idempotency
- **Check:** The `name` is used directly from `var.name` without transformation.
- **Safe:** ✅ No order-dependent logic or transformations.

### Safe References
- **Check:** Direct variable reference `var.name` - no nested access.
- **Safe:** ✅ No null dereference risk.

### Resource Group ID Format
- **Validation:** Regex pattern validates the resource group ID format.
- **Safe:** ✅ Validation ensures correct format before Azure API call.

## Checklist

- ✅ Property in correct local (`azapi_header`)
- ✅ ForceNew wrapped: `name = { value = var.name }` in `replace_triggers_external_values`
- ✅ ALL logic EXACTLY replicated from provider (validations match Go code)
- ✅ Validations IMPLEMENTED in variables.tf (all three validation rules)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: N/A (first task, no deferrals)
- ✅ Deferred work from following.md: N/A (file doesn't exist yet)
- ✅ Critical review (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis in proof
- ✅ Proof created
- ✅ track.md updated to Pending for check
- ✅ Self-Review: Only added what Task #1 requires (name, resource_group_id, azapi_header structure, initial Shadow Module files)

## Initial Shadow Module Files Created

As the first executor, created the following files:
1. ✅ `migrate_main.tf` - Complete structure with locals
2. ✅ `migrate_variables.tf` - New variables (resource_group_id)
3. ✅ `migrate_outputs.tf` - Output definitions
4. ✅ `migrate_validation.tf` - Placeholder for complex validations
5. ✅ `terraform.tf` - Already existed (not modified, already has correct azapi provider configuration)

All files follow the templates specified in executor.md section "Initial Templates (First Executor)".

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #1 - name

### Issues Identified

#### Issue 1: sensitive_body_version Structure Contains Comments

**Problem:**
The `sensitive_body_version` local in `migrate_main.tf` contained inline comments explaining the structure, which could cause syntax issues and violates the clean implementation requirement.

**Executor's Implementation:**
```hcl
sensitive_body_version = {
  # All possible sensitive field paths with try(tostring(...), "null")
  # Example: "properties.virtualMachineProfile.userData" = try(tostring(var.user_data_version), "null")
}
```

**Why This Violates executor.md:**
While the structure is correct (empty map for Task #1 since no sensitive fields exist yet), inline comments inside the map definition are not necessary and should be avoided in implementation files. Comments belong in documentation, not in the actual code structure.

**Expected Behavior:**
- Clean, empty map structure for initial task
- Comments and examples should be in proof documents, not in code

**Root Cause:**
Executor included instructional comments in the implementation code that should have been in proof documentation only.

### Corrections Made

#### Fix 1: Clean sensitive_body_version Structure

**Changed Files:**
- `migrate_main.tf`: Removed inline comments from `sensitive_body_version`

**New Implementation:**
```hcl
sensitive_body_version = {}
```

**Why This is EXACT:**
Matches the executor.md requirement for an empty map structure when no sensitive fields exist yet. Future tasks will add entries to this map as sensitive fields are implemented.

**Verification:**
- Scenario 1: No sensitive fields → Empty map `{}` ✅
- Scenario 2: Future task adds sensitive field → Will add entry like `"path.to.field" = try(tostring(var.field_version), "null")` ✅
- Edge Case: Terraform correctly parses empty map ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The implementation correctly:

1. ✅ Creates complete `azapi_header` with all required fields (type, name, location, parent_id, tags, ignore_null_property, retry)
2. ✅ Implements ForceNew logic with stable key wrapping: `name = { value = var.name }`
3. ✅ Replicates ALL three provider validations exactly (alphanumeric, min length 5, max length 50)
4. ✅ Creates `resource_group_id` variable in `migrate_variables.tf` with proper validation
5. ✅ Initializes all required locals (body, sensitive_body, sensitive_body_version, replace_triggers_external_values, locks)
6. ✅ Creates all required migrate_* output files
7. ✅ Uses clean implementation without instructional comments
8. ✅ Correctly notes terraform.tf already exists with appropriate azapi provider configuration

**Status:** CORRECTED AND APPROVED ✅

---
