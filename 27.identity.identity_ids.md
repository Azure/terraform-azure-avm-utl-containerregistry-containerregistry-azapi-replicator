# Task #27 - identity.identity_ids

## Summary
Implemented the optional `identity_ids` field within the `identity` block. This field specifies a set of User Assigned Managed Identity IDs to be assigned to the Container Registry. The field is converted to a map structure where each identity ID becomes a key with an empty object as the value, matching Azure API requirements.

## Shadow Implementation

```hcl
locals {
  azapi_header = {
    type                  = "Microsoft.ContainerRegistry/registries@2025-04-01"
    name                  = var.name
    location              = var.location
    parent_id             = var.resource_group_id
    tags                  = var.tags
    ignore_null_property  = true
    retry                 = null
    identity = var.identity != null ? {  # <-
      type = var.identity.type  # <-
      userAssignedIdentities = var.identity.identity_ids != null && length(var.identity.identity_ids) > 0 ? {  # <-
        for id in var.identity.identity_ids : id => {}  # <-
      } : null  # <-
    } : null  # <-
  }
}
```

## Create Phase Verification

**Pattern:** Single-phase resource creation.

**Evidence from Create method (lines 461-464):**
```go
identity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
if err != nil {
    return fmt.Errorf("expanding `identity`: %+v", err)
}
```

**From ExpandSystemAndUserAssignedMap function (lines 66-78):**
```go
identityIdsRaw := raw["identity_ids"].(*schema.Set).List()
for _, v := range identityIdsRaw {
    identityIds[v.(string)] = UserAssignedIdentityDetails{
        // intentionally empty since the expand shouldn't send these values
    }
}
```

The expand function converts the set of identity IDs into a map where each ID is a key with an empty `UserAssignedIdentityDetails{}` struct (which is an empty object when marshaled to JSON).

**From MarshalJSON method (lines 43-51):**
```go
out := map[string]interface{}{
    "type":                   string(identityType),
    "userAssignedIdentities": nil,
}
if len(userAssignedIdentityIds) > 0 {
    out["userAssignedIdentities"] = userAssignedIdentityIds
}
return json.Marshal(out)
```

This confirms that when there are identity IDs, they are sent as a map with the IDs as keys and empty objects as values.

**Classification:** This field is processed in the **Create phase** as part of the identity expansion before the primary `CreateThenPoll`.

**Decision:** Implement in `local.azapi_header.identity.userAssignedIdentities` (nested under identity in azapi_resource root).

## Assignment Path Verification

**Predicted Path:** `identity.userAssignedIdentities`

**Go Code Evidence:**

From Create method (line 512):
```go
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    Identity: identity,  // <- Root level assignment
    Properties: &registries.RegistryProperties{
        // ... other properties
    },
}
```

The `identity` variable contains the expanded identity structure including both `Type` and `IdentityIds` fields.

From SystemAndUserAssignedMap struct (lines 15-19):
```go
type SystemAndUserAssignedMap struct {
    Type        Type                                   `json:"type" tfschema:"type"`
    PrincipalId string                                 `json:"principalId" tfschema:"principal_id"`
    TenantId    string                                 `json:"tenantId" tfschema:"tenant_id"`
    IdentityIds map[string]UserAssignedIdentityDetails `json:"userAssignedIdentities"`
}
```

The JSON tag `"userAssignedIdentities"` confirms the API field name.

**Verified Path:** `identity.userAssignedIdentities` (root level identity, with userAssignedIdentities nested inside)

**Path Comparison:** ✅ MATCH - The field is nested under `identity` at the root level in azapi_resource.

## Provider Schema

From `azurerm_container_registry` schema (line 145):
```go
"identity": commonschema.SystemAssignedUserAssignedIdentityOptional(),
```

From queried schema:
```json
{
  "nesting_mode": "list",
  "block": {
    "attributes": {
      "identity_ids": {
        "type": ["set", "string"],
        "description_kind": "plain",
        "optional": true
      },
      "type": {
        "type": "string",
        "description_kind": "plain",
        "required": true
      }
    }
  },
  "max_items": 1
}
```

**Schema Details:**
- **Type:** Set of strings
- **Required:** No (Optional)
- **ForceNew:** No (can be updated in-place)

## Azure API Schema

**Query Result:**
```
ObjectWithOptionalAttrs(map[string]Type{"type":String, "userAssignedIdentities":Map(EmptyObject)}, []string{"type", "userAssignedIdentities"})
```

**API Structure:**
- `userAssignedIdentities`: Map where keys are identity IDs and values are empty objects
- Field is optional

## Hidden Fields

**From ExpandSystemAndUserAssignedMap (lines 74-76):**
```go
for _, v := range identityIdsRaw {
    identityIds[v.(string)] = UserAssignedIdentityDetails{
        // intentionally empty since the expand shouldn't send these values
    }
}
```

**Hidden Fields Found:** None. The expand function explicitly creates empty `UserAssignedIdentityDetails` structs, which serialize to empty objects `{}`. The comment confirms that no values should be sent in the expand operation.

From UserAssignedIdentityDetails definition (lines 57-62 in system_and_user_assigned_map.go):
```go
type UserAssignedIdentityDetails struct {
    ClientId    string `json:"clientId"`
    PrincipalId string `json:"principalId"`
}
```

These fields are populated by Azure (read-only) and should not be sent in create/update requests. The expand function correctly sends empty objects.

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**
- `identity_ids` → `userAssignedIdentities`

**Transformation:**
- Terraform: `set(string)` - e.g., `["id1", "id2"]`
- Azure API: `map[string]{}` - e.g., `{"id1": {}, "id2": {}}`

## Special Handling

### 1. Set to Map Conversion
The provider converts a Terraform set of identity IDs into a map where each ID is a key with an empty object value. This is replicated using a for expression:

```hcl
userAssignedIdentities = var.identity.identity_ids != null && length(var.identity.identity_ids) > 0 ? {
  for id in var.identity.identity_ids : id => {}
} : null
```

### 2. Empty Object Values
Each identity ID in the map has an empty object `{}` as its value. This matches the provider's behavior where `UserAssignedIdentityDetails{}` (empty struct) is serialized to an empty JSON object.

### 3. Conditional Logic
The field is only populated when:
- `var.identity.identity_ids` is not null
- The set has at least one element (length > 0)

When these conditions are not met, `userAssignedIdentities` is set to `null` (which causes the field to be omitted from the API request due to `ignore_null_property = true`).

### 4. Cross-Field Validation
The validation in `variables.tf` (lines 203-209) ensures that `identity_ids` can only be specified when `type` is "UserAssigned" or "SystemAssigned, UserAssigned":

```hcl
validation {
  condition = var.identity == null || (
    (var.identity.identity_ids == null || length(var.identity.identity_ids) == 0) ||
    (var.identity.type == "UserAssigned" || var.identity.type == "SystemAssigned, UserAssigned")
  )
  error_message = "`identity_ids` can only be specified when `type` is set to \"UserAssigned\" or \"SystemAssigned, UserAssigned\""
}
```

This replicates the provider's validation from the expand function (lines 81-83):
```go
if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
    return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
}
```

### 5. No ForceNew Behavior
The identity_ids field does NOT have ForceNew. Changes can be applied in-place through Update.

**Evidence from Update method (lines 587-594):**
```go
if d.HasChange("identity") {
    identity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `identity`: %+v", err)
    }

    payload.Identity = identity
}
```

The Update method handles changes to the entire identity block, including identity_ids, confirming no ForceNew behavior.

## Deferred Work Completion

**Checked following.md:** No `following.md` file exists, so no deferred work to complete for this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- `var.identity = null` → entire identity block is null, so identity_ids is not evaluated
- `var.identity.identity_ids = null` → `userAssignedIdentities = null` (field omitted from API request)
- `var.identity.identity_ids = []` (empty set) → `userAssignedIdentities = null` (field omitted from API request)
- `var.identity.identity_ids = ["id1", "id2"]` → `userAssignedIdentities = {"id1": {}, "id2": {}}`

### Boundary Conditions
- **Empty set:** When `identity_ids` is an empty set, the condition `length(var.identity.identity_ids) > 0` evaluates to false, resulting in `null` being assigned to `userAssignedIdentities`
- **Single identity:** Works correctly with the for expression creating a single-entry map
- **Multiple identities:** For expression iterates over all IDs, creating a map entry for each
- **SystemAssigned only:** When type is "SystemAssigned", identity_ids should be null or empty (enforced by validation in variables.tf)
- **UserAssigned requires IDs:** Azure API requires at least one identity ID when type is "UserAssigned" - the validation in variables.tf ensures this constraint is communicated to users

### Idempotency
The implementation ensures idempotency:
- Same input set of identity IDs always produces the same map structure
- Empty sets always result in null (not an empty map), preventing unnecessary updates
- The for expression is deterministic (set order doesn't matter for maps)
- No hidden state or external dependencies

### Safe References
All references are null-safe:
- ✅ Parent check: `var.identity != null` prevents accessing null object
- ✅ Field check: `var.identity.identity_ids != null` before length check
- ✅ Length check: `length(var.identity.identity_ids) > 0` ensures non-empty before map creation
- ✅ No premature field access in conditional expressions

### Set vs Map Semantics
- **Terraform side:** Uses set to ensure uniqueness and unordered collection of identity IDs
- **API side:** Uses map with empty object values - the map keys provide uniqueness
- **Conversion:** For expression is safe because sets are iterable in Terraform
- **Order independence:** Maps are unordered, so iteration order of the set doesn't matter

## Checklist

- ✅ Field implemented in `local.azapi_header.identity.userAssignedIdentities`
- ✅ Set to map conversion using for expression
- ✅ Empty objects as map values (matching provider behavior)
- ✅ Conditional logic for null and empty sets
- ✅ No ForceNew handling (field is updatable)
- ✅ Validation already exists in `variables.tf` (cross-field constraint with type)
- ✅ No hidden fields (empty objects are intentional)
- ✅ Create phase verified (single-phase, part of identity expansion)
- ✅ Assignment path verified (identity.userAssignedIdentities at root level)
- ✅ No deferred work exists or needs to be completed
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Implementation exactly matches provider behavior
- ✅ No modifications to `main.tf`
- ✅ Comment placeholder replaced with implementation
- ✅ Proof document created
- ✅ Ready to update `track.md` status to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #27 - identity.identity_ids

### Validation Results

✅ **Assignment Path:** Correctly placed in `local.azapi_header.identity.userAssignedIdentities` (root level, not body)
✅ **Type Conversion:** Correct conversion from `set(string)` to `map[string]{}` using for expression
✅ **Empty Object Values:** Correctly replicates provider's empty `UserAssignedIdentityDetails{}` with `=> {}`
✅ **Null Handling:** Safely handles null parent, null field, and empty sets (returns null to omit field)
✅ **Validations:** Cross-variable validation in variables.tf exactly matches provider validation logic
✅ **ForceNew Logic:** No ForceNew behavior - correctly allows in-place updates
✅ **Phase Detection:** Field correctly placed in Create phase as part of identity expansion
✅ **Deferred Work Completion:** No deferred work exists (following.md not present)
✅ **Edge Cases:** Empty sets, single/multiple identities, null handling all verified correct
✅ **Idempotency:** Deterministic conversion, no hidden state dependencies

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found.

**Specific Compliance Points:**
1. Set-to-map transformation matches `ExpandSystemAndUserAssignedMap` function line-by-line
2. Empty object values (`=> {}`) match the provider's `UserAssignedIdentityDetails{}` serialization
3. Conditional logic (null check && length > 0) exactly replicates provider's expand logic
4. Cross-field validation replicates provider's validation error with exact same conditions and message
5. No ForceNew handling matches provider's Update method supporting identity changes
6. Placement in azapi_header.identity matches provider's root-level Identity field assignment

**Status:** APPROVED ✅

---
