# Task #17 - encryption Block Structure Skeleton

## Summary
Created the conditional block skeleton for the `encryption` block with comment placeholders for child arguments (Task #18, #19). The block is optional and requires Premium SKU. Identified hidden field `status` that is always set to "enabled" by the provider.

## Shadow Implementation
```hcl
# In migrate_main.tf
locals {
  body = {
    properties = merge(
      {
        # ... existing fields ...
      },
      var.encryption != null && length(var.encryption) > 0 ? { # <-
        encryption = { # <-
          # keyVaultProperties = ... # Task #18, #19 # <-
          # status = ... # Hidden field, see proof # <-
        } # <-
      } : {} # <-
    )
  }
}

# In variables.tf
variable "encryption" {
  # ... existing definition ...
  
  validation { # <-
    condition     = var.encryption == null || length(var.encryption) == 0 || var.sku == "Premium" # <-
    error_message = "an ACR encryption can only be applied when using the Premium Sku" # <-
  } # <-

  validation { # <-
    condition     = var.encryption == null || length(var.encryption) <= 1 # <-
    error_message = "encryption block can have at most 1 item" # <-
  } # <-
}
```

## Create Phase Verification

### Provider Create Method Evidence
From `resourceContainerRegistryCreate` (lines 405-547):
```go
parameters := registries.Registry{
    Location: location.Normalize(d.Get("location").(string)),
    Sku: registries.Sku{
        Name: registries.SkuName(sku),
        Tier: pointer.To(registries.SkuTier(sku)),
    },
    Identity: identity,
    Properties: &registries.RegistryProperties{
        AdminUserEnabled: pointer.To(d.Get("admin_enabled").(bool)),
        Encryption:       expandEncryption(d.Get("encryption").([]interface{})), // <- Line 505
        NetworkRuleSet:   networkRuleSet,
        // ... other properties
    },
    Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
}

if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
    return fmt.Errorf("creating %s: %+v", id, err)
}
```

**Pattern:** Single-phase - encryption is set during the primary `CreateThenPoll` operation.

**Field Classification:** Create phase - included in the initial resource creation payload.

**Decision:** Implement in `local.body.properties.encryption` (not post-creation).

## Assignment Path Verification

### Predicted Path
`properties.encryption`

### Go Code Evidence - Tracing Assignment Path
From `resourceContainerRegistryCreate` (line 505):
```go
Properties: &registries.RegistryProperties{
    Encryption:       expandEncryption(d.Get("encryption").([]interface{})),
}
```

The `Encryption` field is directly assigned to the `Properties` struct at line 505. The struct assignment shows:
- `Properties` is assigned as `&registries.RegistryProperties` (pointer)
- Within `Properties`, `Encryption` is assigned the result of `expandEncryption()`

From `expandEncryption` function (lines 1013-1025):
```go
func expandEncryption(input []interface{}) *registries.EncryptionProperty {
    if len(input) == 0 {
        return nil
    }
    v := input[0].(map[string]interface{})
    return &registries.EncryptionProperty{
        KeyVaultProperties: &registries.KeyVaultProperties{
            Identity:      pointer.To(v["identity_client_id"].(string)),
            KeyIdentifier: pointer.To(v["key_vault_key_id"].(string)),
        },
        Status: pointer.To(registries.EncryptionStatusEnabled),
    }
}
```

**Assignment Trace:**
1. `expandEncryption()` returns `*registries.EncryptionProperty`
2. Assigned to `Properties.Encryption` field
3. `Properties` is marshaled to `properties` in Azure API request body
4. Final path: `properties.encryption`

### Verified Path
`properties.encryption`

### Path Comparison
✅ **MATCH** - Predicted path matches verified path.

## Provider Schema

### Schema Definition (lines 147-163)
```go
"encryption": {
    Type:       pluginsdk.TypeList,
    Optional:   true,
    ConfigMode: pluginsdk.SchemaConfigModeAttr,
    MaxItems:   1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "identity_client_id": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ValidateFunc: validation.IsUUID,
            },
            "key_vault_key_id": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ValidateFunc: keyVaultValidate.NestedItemIdWithOptionalVersion,
            },
        },
    },
},
```

**Key Properties:**
- **Type:** TypeList
- **Optional:** true
- **MaxItems:** 1
- **ConfigMode:** SchemaConfigModeAttr
- **ForceNew:** Not specified (false)
- **Computed:** Added in provider code for backward compatibility (lines 389-391)

**Child Arguments:**
- `identity_client_id`: Required, String, UUID validation
- `key_vault_key_id`: Required, String, Key Vault nested item ID with optional version validation

## Azure API Schema

### Query Result
From `query_azapi_resource_schema`:
```
properties.encryption: ObjectWithOptionalAttrs(
  map[string]Type{
    "keyVaultProperties": ObjectWithOptionalAttrs(
      map[string]Type{
        "identity": String,
        "keyIdentifier": String
      },
      []string{"identity", "keyIdentifier"}
    ),
    "status": String
  },
  []string{"keyVaultProperties", "status"}
)
```

**Structure:**
- Path: `properties.encryption`
- Type: Object (optional)
- Child properties:
  - `keyVaultProperties.identity` (optional) - maps to `identity_client_id`
  - `keyVaultProperties.keyIdentifier` (optional) - maps to `key_vault_key_id`
  - `status` (optional) - hidden field, not in Terraform schema

## Hidden Fields

### Hidden Field: `status`
From `expandEncryption` function (line 1022):
```go
return &registries.EncryptionProperty{
    KeyVaultProperties: &registries.KeyVaultProperties{
        Identity:      pointer.To(v["identity_client_id"].(string)),
        KeyIdentifier: pointer.To(v["key_vault_key_id"].(string)),
    },
    Status: pointer.To(registries.EncryptionStatusEnabled), // <- Always "enabled"
}
```

**Analysis:**
- **Field Name:** `status`
- **Azure API Path:** `properties.encryption.status`
- **Value:** Always set to `registries.EncryptionStatusEnabled` (constant "enabled")
- **User Configurable:** No - hardcoded by provider
- **Reason:** When encryption is configured, it's automatically enabled. The provider doesn't expose a toggle for this.

**Implementation:**
```hcl
# Task #18 or #19 will implement:
encryption = {
  keyVaultProperties = {
    identity      = var.encryption[0].identity_client_id
    keyIdentifier = var.encryption[0].key_vault_key_id
  }
  status = "enabled"  # Hidden field - always enabled when encryption is configured
}
```

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `encryption` | `encryption` | Block (MaxItems: 1) |
| `identity_client_id` | `keyVaultProperties.identity` | Task #18 |
| `key_vault_key_id` | `keyVaultProperties.keyIdentifier` | Task #19 |
| (hidden) | `status` | Always "enabled" when encryption is set |

## Special Handling

### Validation
Added two validations to `variables.tf`:

1. **Premium SKU Requirement:**
```hcl
validation {
  condition     = var.encryption == null || length(var.encryption) == 0 || var.sku == "Premium"
  error_message = "an ACR encryption can only be applied when using the Premium Sku"
}
```
**Source:** CustomizeDiff logic (lines 368-370):
```go
encryptionEnabled, ok := d.GetOk("encryption")
if ok && len(encryptionEnabled.([]interface{})) > 0 && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
    return errors.New("an ACR encryption can only be applied when using the Premium Sku")
}
```

2. **MaxItems Validation:**
```hcl
validation {
  condition     = var.encryption == null || length(var.encryption) <= 1
  error_message = "encryption block can have at most 1 item"
}
```
**Source:** Schema definition (line 150): `MaxItems: 1`

### Block Conditionality
```hcl
var.encryption != null && length(var.encryption) > 0 ? {
  encryption = {
    # ... fields ...
  }
} : {}
```
**Reason:** The encryption block is optional. It should only be included in the API payload when the user provides a value.

### ForceNew Behavior
- **Schema:** No `ForceNew: true` specified
- **CustomizeDiff:** No ForceNew logic for encryption field
- **Conclusion:** Changes to encryption can be applied via Update operation
- **Implementation:** No entry in `replace_triggers_external_values` needed

### Sensitive Fields
No sensitive fields in this block. Both `identity_client_id` and `key_vault_key_id` are identifiers/references, not secrets.

## Child Tasks Ready for Delegation

The following child tasks are now ready for implementation:

- **Task #18:** `encryption.identity_client_id` - Implement the identity client ID field
- **Task #19:** `encryption.key_vault_key_id` - Implement the key vault key ID field

Both tasks should:
1. Replace the comment placeholder in the encryption block
2. Implement field-level validations (UUID for #18, Key Vault ID format for #19)
3. Map to Azure API path `properties.encryption.keyVaultProperties.{identity|keyIdentifier}`
4. Implement the hidden `status` field (one of the tasks should handle this)

## Critical Review & Edge Case Analysis

### Null Semantics
- **`null`**: Encryption is not configured - omit entire encryption block from API payload
- **Empty list `[]`**: Same as null - omit entire encryption block
- **List with 1 item**: Configure encryption with provided values

### Edge Cases

1. **Empty List Handling:**
   ```hcl
   var.encryption != null && length(var.encryption) > 0 ? {...} : {}
   ```
   This ensures both `null` and `[]` result in no encryption block being sent.

2. **MaxItems Enforcement:**
   Validation ensures users can't provide more than 1 encryption configuration.

3. **SKU Dependency:**
   Validation ensures encryption can only be set with Premium SKU. If user downgrades SKU, they must remove encryption first.

4. **Idempotency:**
   Since encryption is not ForceNew, repeated applies with same values won't cause replacements.

5. **Safe References:**
   Using `length(var.encryption) > 0` is safe because we first check `var.encryption != null`.
   Using `var.encryption[0]` in child tasks will be safe because the condition guarantees at least 1 item exists.

### Boundary Conditions
- **Minimum:** 0 items (null or empty list) - valid, no encryption
- **Maximum:** 1 item (enforced by validation) - valid
- **More than 1:** Rejected at validation time

### Hidden Field Consistency
The `status` field is always set to "enabled" when encryption is present. This matches provider behavior exactly - there's no way to have an encryption configuration that's disabled.

## Checklist

- ✅ Block skeleton created with conditional logic
- ✅ Comment placeholders added for child arguments (Task #18, #19)
- ✅ Hidden field `status` identified and documented
- ✅ Validations implemented in variables.tf (Premium SKU requirement, MaxItems)
- ✅ Create phase verified (single-phase, in primary create)
- ✅ Assignment path traced and verified
- ✅ Provider schema analyzed
- ✅ Azure API schema queried
- ✅ Mapping documented
- ✅ ForceNew checked (not applicable)
- ✅ Sensitive fields checked (none)
- ✅ Critical review performed
- ✅ Edge case analysis completed
- ✅ Child tasks identified (#18, #19)
- ✅ Proof document created
- ✅ Self-review: Only skeleton created, no argument implementations (those belong to Task #18, #19)

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2026-01-26
**Task:** #17 - encryption

### Issues Identified

#### Issue 1: Hidden Field Not Implemented in Skeleton

**Problem:**
The proof document correctly identified the hidden field `status` that is always set to "enabled" when encryption is configured. However, the executor left it as a comment placeholder instead of implementing it in the skeleton.

**Executor's Implementation:**
```hcl
var.encryption != null && length(var.encryption) > 0 ? {
  encryption = {
    # keyVaultProperties = ... # Task #18, #19
    # status = ... # Hidden field, see proof
  }
} : {}
```

**Why This Violates executor.md:**
From executor.md, Type 3 tasks (Block Structure Skeleton) have explicit steps:
> **Steps:** (1) Check `main.tf`, (2) Create conditional skeleton with placeholders, (3) **Check expand for hidden**, (4) Create proof, (5) Update `track.md` status to `Pending for check`.

The `status` field is:
- Always present when encryption block exists
- A constant value "enabled" (not dependent on user input)
- Not dependent on any child task values (#18, #19 handle keyVaultProperties)
- Identified in the expand function (lines 1022 in Go code)

**Provider's Actual Behavior:**
From `expandEncryption` function (line 1022):
```go
return &registries.EncryptionProperty{
    KeyVaultProperties: &registries.KeyVaultProperties{
        Identity:      pointer.To(v["identity_client_id"].(string)),
        KeyIdentifier: pointer.To(v["key_vault_key_id"].(string)),
    },
    Status: pointer.To(registries.EncryptionStatusEnabled), // <- Always "enabled"
}
```

**Expected Behavior:**
- When encryption block is present, `status` field is always set to "enabled"
- This is not configurable by the user
- It should be implemented in the skeleton (Task #17), not deferred to child tasks

**Root Cause:**
Executor identified the hidden field correctly in the proof but incorrectly left it as a comment instead of implementing the constant value directly in the skeleton.

### Corrections Made

#### Fix 1: Implement Hidden Field in Skeleton

**Changed Files:**
- `migrate_main.tf`: Added the hidden `status` field with constant value "enabled"

**New Implementation:**
```hcl
var.encryption != null && length(var.encryption) > 0 ? {
  encryption = {
    # keyVaultProperties = ... # Task #18, #19
    status = "enabled" # Hidden field - always enabled when encryption is configured
  }
} : {}
```

**Why This is EXACT:**
This exactly matches the provider behavior where `Status` is unconditionally set to `registries.EncryptionStatusEnabled` (which is the string value "enabled") whenever the encryption block is present.

**Verification:**
- Scenario 1: `encryption = null` → No encryption block sent ✅
- Scenario 2: `encryption = []` → No encryption block sent ✅
- Scenario 3: `encryption = [{...}]` → encryption block with status="enabled" sent ✅
- Edge Case: No user control over status value → Always "enabled" when present ✅

### Final Verification

**Re-read Implementation:**
✅ Verified `migrate_main.tf` now contains `status = "enabled"` in the encryption block
✅ Verified the comment placeholder for keyVaultProperties remains for Task #18, #19
✅ Verified the conditional logic remains correct
✅ Verified no other changes were made outside the scope

**Compliance Statement:**
After correction, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The skeleton includes all hidden fields and provides proper placeholders for child task arguments.

### Validation Results

✅ **Block Skeleton:** Correctly structured with proper conditional logic
✅ **Hidden Fields:** `status` field now implemented with constant value "enabled"
✅ **Phase Detection:** Correctly placed in `local.body.properties` (Create phase)
✅ **Validations:** Both Premium SKU requirement and MaxItems validations implemented in variables.tf
✅ **Comment Placeholders:** Properly placed for Task #18, #19 to implement keyVaultProperties
✅ **Assignment Path:** Correctly verified as `properties.encryption`
✅ **Null Handling:** Correctly handles both null and empty list
✅ **Edge Cases:** All edge cases properly analyzed and handled

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The block skeleton includes the hidden `status` field and provides clear placeholders for child tasks.

**Status:** CORRECTED AND APPROVED ✅

---
